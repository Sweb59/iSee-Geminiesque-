<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Assistant Réfraction - Dashboard Final</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&display=swap" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  
<style>
  /* --- CHARTE GRAPHIQUE --- */
  :root { 
      --bg-main: #FCF9F2;       
      --primary: #04ABC6;            
      --primary-dark: #03889E;    
      --primary-deep: #026070;    
      --primary-light: #E0F6F8;   
      --primary-border: #8CD6E2;
      --panel: #FFFFFF;            
      --text-main: #37474F;        
      --text-muted: #78909C;        
      --border: #CFD8DC;
  }

  /* RESET & BASE */
  * { box-sizing: border-box; }
  body { 
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
      background-color: var(--bg-main); 
      color: var(--text-main); 
      margin: 0; padding: 0;
      height: 100vh; 
      overflow: hidden; 
      font-size: 13px;
  }

/* --- LAYOUT GRID UNIQUE (ONE SCREEN) --- */
  
  /* Conteneur Maitre : Prend tout l'écran, pas de scroll global sauf si nécessaire */
  .app-container { 
      display: grid;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #FCF9F2;
      padding: 10px;
      gap: 10px;

      /* GRILLE DE PRÉCISION : 20x20 
         Chaque cellule fait 5% de largeur et 5% de hauteur.
         Vous pouvez placer n'importe quel élément avec grid-row / grid-column.
      */
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(20, 1fr);
  }

  /* --- PLACEMENT DES ÉLÉMENTS (C'EST ICI QUE VOUS MODIFIEZ POUR BOUGER LES BLOCS) --- */

  /* 1. Zone Patient (Ligne 1, Toute largeur) */
  /* 1. Zone Patient (Barre du haut) - MODIFIÉE */
 /* 1. Zone Patient (Barre du haut) - FONDUE DANS LE DÉCOR */
  #zonePatient {
      grid-column: 1 / 21;  
      grid-row: 1 / 3;      
      
      /* FOND CRÈME (Identique au body) */
      background: #FCF9F2; 
      
      /* PLUS DE BORDURE (Pour fondre la zone) */
      border: none; 
      
      border-radius: 0; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 0 30px;
      position: relative; 
  }

  /* Style du Chrono (TAILLE RÉDUITE) */
  #displayChrono {
      font-weight: 800; 
      color: var(--primary-deep);
      
      /* Taille réduite pour être discret */
      font-size: 1.3rem; 
      
      font-family: 'Montserrat', sans-serif;
      opacity: 0.8; /* Un peu moins agressif visuellement */
  }

  /* Style du Nom/Prénom/Age */
  .patient-info-block {
      font-size: 1.8rem;
      font-weight: 700;
      color: #37474F;
      text-transform: uppercase;
      
      display: flex;       
      align-items: baseline; /* Aligne le texte sur la ligne d'écriture */
      gap: 15px;           /* Espace entre le nom et l'âge */
  }
  /* La Pastille de Profil (RONDE et CENTRÉE sur ZoneLettres) */
  .pat-profile-badge {
      position: absolute;
      
      /* POSITIONNEMENT : 
         La zone lettres est colonnes 14 à 19. Le centre est environ à 80% de la largeur totale.
      */
      left: 80%; 
      top: 50%;
      transform: translate(-50%, -50%); /* Centrage parfait sur le point 80% */
      
      width: 50px; 
      height: 50px;
      border-radius: 50%; /* ROND */
      
      display: flex;
      justify-content: center;
      align-items: center;
      
      color: white;
      font-weight: 800;
      font-size: 1.8rem; /* Juste le chiffre en gros */
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      border: 2px solid white;
  }
  /* 2. Infos / Pilotage (Juste en dessous) */

 /* 2-A. Zone Pilotage (Alignée sur les Données : Col 1-13) */
 /* 2-A. Zone Pilotage (Alignée sur les Données : Col 1-13) */
 /* 2-A. Zone Pilotage */
  #zonePilotage {
      grid-column: 1 / 13; 
      /* ON DESCEND LA ZONE : Lignes 6 à 8 */
      grid-row: 6 / 8;     
      
      display: flex; 
      flex-direction: column; 
      /* ON COLLE LE CONTENU EN BAS pour toucher les cartes */
      justify-content: flex-end; 
      align-items: center;    
      padding-bottom: 5px;
      
      /* Fond transparent pour que ça fasse "partie" du bloc du dessous */
      background: transparent; 
  }
  /* 2-B. Zone Visuels VA (Alignée sur les Lettres : Col 16-21) */
 /* 2-B. Zone Visuels VA (Alignée sur le Pilotage : Col 16-21) */
 /* 2-B. Zone Visuels VA (Les deux boutons -- / --) */
  #zoneVisuels {
      /* ALIGNEMENT HORIZONTAL : On cale sur la même largeur que #zoneLettres */
      grid-column: 14 / 19; 
      
      /* ALIGNEMENT VERTICAL : On place juste au-dessus (Lignes 5 à 7) */
      grid-row: 7 / 9;       
      
      display: flex; 
      /* On centre le contenu pour qu'il soit bien au milieu de la colonne */
      justify-content: center; 
      align-items: flex-end; /* Collé en bas de la case pour être proche des lettres */
      
      padding-bottom: 5px;
      
      background: transparent; 
      border-radius: 8px;
  }

  /* 3. Données Techniques (Gauche Verticale ?) - À vous de régler */
  /* 3. Données Techniques (HORIZONTALE : Lignes 5 à 7) */
/* 3. Données Techniques (GAUCHE : 75% Largeur) */
/* 3. Données Techniques (GAUCHE : 60% Largeur) */
/* 3. Données Techniques (GAUCHE : 60% Largeur) */
  /* 3. Données Techniques (GAUCHE : 60% Largeur) */
  #examDataStrip {
      grid-column: 1 / 13;  
      /* ON COLLE CETTE ZONE JUSTE SOUS LE PILOTAGE (Ligne 8) */
      grid-row: 8 / 18;     
      
      display: flex;
      flex-direction: row;
      justify-content: center; 
      
      /* C'EST ICI LE SECRET : ON COLLE LES CARTES TOUT EN HAUT DE LEUR ZONE */
      align-items: flex-start; 
      
      gap: 15px; 
      background: transparent;
      overflow: visible;
      padding: 5px;
  }
  
  /* --- STYLE GÉNÉRAL DES CARTES (AR / Fronto) --- */
  .exam-data-strip .data-col { 
      flex: 0 0 110px; 
      height: auto; min-height: 180px;
      
      display: flex; 
      flex-direction: column; 
      justify-content: center;
      
      background: #FCF9F2; 
      
      /* C'EST ICI LE CHANGEMENT : BORDURE PLUS LARGE (4px) */
      border: 4px solid #04ABC6; 
      
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(4, 171, 198, 0.1);
  }

  /* --- SPÉCIFIQUE : Carte Subjectif (Quand elle est INACTIVE) --- */
  /* Elle prend le style du bouton "FERMÉ" (Marron foncé) */
  .exam-data-strip .col-active {
      background: #5D4037 !important; 
      border-color: #5D4037 !important; 
  }

  /* Force la couleur du TEXTE à l'intérieur (Beige clair #D7CCC8) */
  .exam-data-strip .col-active .col-title,
  .exam-data-strip .col-active .val-input,
  .exam-data-strip .col-active .val-big,
  .exam-data-strip .col-active span {
      color: #D7CCC8 !important;
      border-bottom-color: rgba(215, 204, 200, 0.3);
  }

  /* --- SPÉCIFIQUE : Carte Subjectif (Quand elle est ACTIVE/HIGHLIGHT) --- */
  /* Elle devient Cyan (#04ABC6) avec texte Blanc */
  .exam-data-strip .col-active.highlight {
      background: #04ABC6 !important;
      border-color: #026070 !important;
      transform: scale(1.05);
  }
  
  /* Force le texte BLANC quand la carte est active */
  .exam-data-strip .col-active.highlight .col-title,
  .exam-data-strip .col-active.highlight .val-input,
  .exam-data-strip .col-active.highlight .val-big {
      color: #FFFFFF !important;
  }

  /* Suppression des bordures des inputs pour toutes les cartes */
  .exam-data-strip .data-col input, 
  .exam-data-strip .data-col .val-input {
      border: none !important;
      background: transparent !important;
      outline: none;
      box-shadow: none;
      text-align: center;
  }
/* --- COLONNE VERTÉBRALE (Style CARTE avec BORDURE) --- */
  .center-labels {
      display: flex !important;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      
      width: 70px;         
      min-height: 180px;   /* Même hauteur que les cartes voisines */
      margin: 0 5px;
      
      /* 1. FOND CRÈME */
      background: #FCF9F2;           
      
      /* 2. BORDURE CYAN ÉPAISSE (4px) */
      border: 4px solid #04ABC6;     
      border-radius: 8px;            
      
      /* 3. EFFET DE VOLUME (Ombre) */
      box-shadow: 0 4px 6px rgba(4, 171, 198, 0.1);
  }

  /* Espaceur invisible pour aligner S avec la 1ère valeur */
  .center-labels .col-title {
      height: 20px; 
      margin-bottom: 8px;
      visibility: hidden; 
  }

  /* Style des Cercles (S, C, A) à l'intérieur */
  .center-labels .label-row {
      display: flex;
      align-items: center;
      justify-content: center;
      
      width: 40px;
      height: 40px;
      
      margin: 4px 0; /* Espacement vertical */
      
      border-radius: 50%;
      background-color: #FCF9F2; 
      border: 3px solid #04ABC6; 
      color: #04ABC6;            
      
      font-weight: 800;
      font-family: 'Montserrat', sans-serif;
      font-size: 1.1rem;
  }
  /* 4. Zone Lettres (DROITE : Colonnes 16-21) */
  /* 4. Zone Lettres (DROITE : Colonnes 16-21) */
  /* 4. Zone Lettres (DROITE) */
  /* 4. Zone Lettres (DROITE) - CORRIGÉ POUR CENTRAGE */
 /* 4. Zone Lettres (DROITE) - MODIFIÉ (Taille, Position, Bordure) */
  /* 4. Zone Lettres (DROITE) - Centrée et Rétrécie */
  /* 4. Zone Lettres (DROITE) - Montée vers le haut */
  /* 4. Zone Lettres (DROITE) - Alignée sous le Pilotage */
/* 4. Zone Lettres (DROITE) - Descendue d'une ligne */
  #zoneLettres {
      grid-column: 14 / 19; 
      
      /* --- NOUVELLE POSITION (+1) --- */
      grid-row: 9 / 15;      
      
      display: flex; 
      flex-direction: column; 
      justify-content: center; 
      align-items: center;
      
      padding: 5px 0;
      background: #FAFAFA;
      border-radius: 8px;
      border: 2px solid #000000;
      overflow: hidden; 
  }
  /* Style d'une ligne de lettres (le conteneur de la ligne) */
/* --- Style d'une ligne de lettres (Conteneur) --- */
  .va-line-row {
      position: relative;
      
      /* LARGEUR 75% (La barre bleue ne prendra que 3/4 de la largeur) */
      width: 75%;        
      margin: 1px auto; /* Centrage horizontal automatique */
      
      padding: 5px 0;
      
      display: flex;
      justify-content: center;
      align-items: center;
      
      border-radius: 4px;
      
      /* Bordure invisible par défaut */
      border: 2px solid transparent; 
      transition: all 0.2s ease;
  }

  /* --- La valeur de l'acuité (le chiffre à droite) --- */
  /* --- La valeur de l'acuité (le chiffre à droite) --- */
  /* --- La valeur de l'acuité (le chiffre à droite) --- */
  .va-tag-value {
      position: absolute;
      
      /* Position horizontale */
      right: -15%; 
      
      top: 50%;          
      transform: translateY(-50%);
      
      font-family: 'Montserrat', sans-serif;
      font-size: 1rem;    
      font-weight: 800;
      color: #000000;     
      
      /* --- NOUVEAU : RESSERRER LES CHIFFRES --- */
      letter-spacing: -1px; /* Valeur négative pour rapprocher les caractères */
      /* --------------------------------------- */
      
      background: transparent; 
      border: none;
      padding: 0;
      z-index: 10;
      
      width: 40px;       
      text-align: right; 
      white-space: nowrap; 
  }

  /* --- LA LIGNE SÉLECTIONNÉE (Active) --- */
  .va-line-row.line-selected {
      background-color: rgba(4, 171, 198, 0.15); /* Fond Cyan léger */
      
      /* BORDURE CYAN */
      border-color: #04ABC6; 
      
      box-shadow: none;
  }

  /* --- Style du texte des lettres --- */
  .optotype-text {
      font-family: 'Montserrat', 'Arial', sans-serif; 
      font-weight: bold;
      color: #333;
      line-height: 1;
      
      /* TAILLE DES LETTRES */
      font-size: 2.5rem !important; 
      letter-spacing: 5px;
      
      /* Centrage du texte */
      text-align: center;
      width: 100%;
  }
 /* 5. Zone Boutons (Bas de l'écran - Centrée) */
  /* 5. Zone Boutons (Bas de l'écran - Remontée) */
  /* 5. Zone Boutons (Bas de l'écran - Sans bordure) */
  #zoneBoutons {
      grid-column: 1 / 21;
      
      /* Position remontée (Ligne 17) */
      grid-row: 17 / 21;     
      
      display: flex; 
      justify-content: center; 
      align-items: flex-start; /* Collé en haut */
      padding-top: 10px;       
      
      /* COULEUR CRÈME */
      background: #FCF9F2; 
      
      /* --- MODIFICATION : PLUS DE LIGNE GRISE --- */
      border-top: none; 
      /* ---------------------------------------- */
      
      z-index: 100;
  }

/* --- STYLE DE LA QUESTION "COMBIEN DE LETTRES LUES ?" --- */
  /* --- STYLE DES QUESTIONS (Lettres lues ET Vitesse) --- */
  #standardButtons p, #cadenceButtons p {
      /* On force la même grande taille pour les deux */
      font-size: 1.6rem !important; 
      
      color: #37474F !important; 
      font-weight: 700 !important;
      margin-bottom: 15px !important;
      margin-top: 0 !important; /* Sécurité pour l'alignement */
  }
  
  /* --- LE SCHOBER (OVERLAY TOTAL) --- */
  #schoberStep {
      position: fixed;   /* Sort de la grille, se place par rapport à la fenêtre */
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: #ECEFF1; /* Fond gris clair pour masquer le reste */
      z-index: 9999;       /* Au dessus de tout */
      
      /* Centrage du contenu */
      display: flex; 
      justify-content: center; 
      align-items: center;
      padding: 20px;
  }
  
  /* IMPORTANT : Quand JS ajoute la classe .hidden, on cache l'overlay */
  #schoberStep.hidden {
      display: none !important;
  }

  /* RESPONSIVE MOBILE */
  @media (max-width: 900px) {
      .app-container {
          display: flex; /* Retour en flex simple pour mobile */
          flex-direction: column;
          height: auto;
          overflow: visible;
      }
      #zonePatient, #zoneInfos, #examDataStrip, #zoneLettres, #zoneBoutons {
          width: 100%;
          grid-column: auto; grid-row: auto; /* Reset grille */
          margin-bottom: 10px;
      }
      #examDataStrip { flex-direction: row; flex-wrap: wrap; }
      .exam-data-strip .data-col { flex: 1; min-width: 100px; }
  }

  /* --- STYLES ÉLÉMENTS SPÉCIFIQUES --- */

  /* Boutons Pilotage */
  .btn-pilot {
      width: 60px; height: 38px; border-radius: 6px; font-weight: bold; cursor: pointer; border: 2px solid transparent; font-size: 1rem;
  }
  .btn-pilot.open { background: #fff; border-color: #B0BEC5; color: #78909C; }
  .btn-pilot.closed { background: #455A64; border-color: #455A64; color: #90A4AE; opacity: 0.5; }
  .btn-pilot.active { background: var(--primary); color: white; border-color: var(--primary-dark); opacity: 1; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
  .btn-pilot.open { background: #FFF; border-color: transparent; color: #78909C; box-shadow: 0 2px 5px rgba(0,0,0,0.05); } 
  .btn-pilot.closed { background: #5D4037; border-color: #5D4037; color: #D7CCC8; opacity: 0.6; }
  .btn-pilot.active { background: var(--primary); color: white; border-color: var(--primary-dark); opacity: 1; box-shadow: 0 3px 8px rgba(0,0,0,0.15); }

  .btn-mode-display {
      padding: 5px 15px; background: #ECEFF1; color: #455A64; font-size: 0.85rem; font-weight: 700; border-radius: 12px; border: 1px solid #CFD8DC; text-transform: uppercase; min-width: 140px; text-align: center;
      padding: 5px 15px; background: #EFEBE9; color: #5D4037;
      font-size: 0.85rem; font-weight: 700; border-radius: 12px; border: none; 
      text-transform: uppercase; min-width: 140px; text-align: center;
  }

  /* Indicateurs Visuels VA */
  .va-box-display {
      width: 80px; height: 50px; border-radius: 8px; display: flex; align-items: center; justify-content: center;
      font-size: 1.5rem; /* Un peu plus petit */
      font-weight: bold; font-family: 'Montserrat', sans-serif;
      background: #FAFAFA; color: #CFD8DC; border: 2px solid #F0F0F0;
      font-size: 1.5rem; font-weight: bold; font-family: 'Montserrat', sans-serif;
      background: #FFF; 
      color: #BCAAA4; border: none; box-shadow: 0 2px 6px rgba(0,0,0,0.05);
  }
  .va-box-display.active-eye {
      background: #E0F7FA; color: var(--primary-dark); border-color: var(--primary); box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      background: #E0F7FA; color: var(--primary-dark); border: 2px solid var(--primary);
  }

 /* --- COLONNES DE DONNÉES --- */
.exam-data-strip { 
    display: flex; 
    gap: 5px;        /* Petit écart entre les cartes */
    width: 100%;     /* <--- IMPORTANT : Prend toute la largeur disponible */
    justify-content: space-between; /* Répartit les cartes équitablement */
    align-items: flex-start; 
}

 /* 1. Colonnes Passives (RA, Fronto) */
.data-col { 
    display: flex; flex-direction: column; 
    /* width: 135px;  <-- SUPPRIMER CETTE LIGNE */
    flex: 1;          /* <--- NOUVEAU : S'étire pour remplir l'espace */
    min-width: 0;     /* Permet à la colonne de rétrécir si besoin */
    
    background: var(--bg-main); 
    border: none; /* Ou votre bordure cyan si vous l'avez gardée */
    
    border-radius: 8px; 
    padding: 5px;     /* Padding interne réduit */
    text-align: center; 
    transition: all 0.3s ease; 
}

  /* ================================================================= */
  /* 2. COLONNE CENTRALE (DESIGN "VERTEBRALE") */
  /* ================================================================= */
  .center-labels {
      display: flex; 
      flex-direction: column; 
      align-items: center;
      
      /* Apparence de la colonne conteneur */
      width: 50px; /* Plus large pour accueillir les cercles */
      padding: 10px 0;
      background-color: #FAFAFA; /* Fond gris très clair */
      border-left: 2px solid #E0E0E0; /* Bordure Gauche */
      border-right: 2px solid #E0E0E0; /* Bordure Droite */
      border-radius: 30px; /* Forme de pilule */
      margin: 0 5px; /* Petit espacement latéral */
      flex-shrink: 0;
  }

  /* Le style des CERCLES (S, C, A) */
  .label-row {
      display: flex; 
      align-items: center; 
      justify-content: center;
      
      /* Dimensions du cercle */
      width: 34px; 
      height: 34px;
      border-radius: 50%; /* Forme ronde */
      border: 2px solid #B0BEC5; /* Bordure du cercle */
      background-color: #FFFFFF; /* Fond blanc pour contraste */
      
      /* Typographie */
      font-weight: 800; 
      font-size: 1.1rem; /* Texte plus grand */
      color: #546E7A; 
      font-family: 'Montserrat', sans-serif;

      /* ALIGNEMENT VERTICAL PRÉCIS */
      /* Doit correspondre à la hauteur + marge des lignes de données */
      margin-bottom: 2px; /* Ajusté pour s'aligner avec les inputs */
  }
  
  /* Cas spécifique pour VA (Cercle Bleu) */
  .va-label {
      margin-top: 5px; 
      border-color: var(--primary); /* Bordure Cyan */
      color: var(--primary); /* Texte Cyan */
      font-size: 1rem;
  }

 /* 3. Carte Subjectif - ÉTAT INACTIF */
.col-active { 
    /* width: 175px; <-- SUPPRIMER CETTE LIGNE */
    flex: 1.2;       /* <--- Un peu plus large que les AR/LM (Ratio 1.2 vs 1) */
    min-width: 0;    /* Important pour le responsive */
    
    z-index: 1; transform: scale(0.98); 
    background-color: #F5F5F5; border: 2px solid #E0E0E0; box-shadow: none; 
    border-radius: 8px; /* Ajout esthétique */
}
  .col-active .col-title { color: #B0BEC5; border-bottom-color: #E0E0E0; }
 .col-active .val-big { 
    color: #B0BEC5; 
    font-size: 1.3rem; /* <--- RÉDUIT (était 1.8rem) */
    font-weight: 800; 
    transition: color 0.2s; 
}
  .col-active #disp_subjOD_va, .col-active #disp_subjOG_va { color: #B0BEC5; font-weight: bold; transition: color 0.2s; }
  .col-active .val-input { color: #B0BEC5 !important; width: 100%; text-align: center; background: transparent; border: none; font-weight: 700; font-size: 1.2rem; }

  /* ================================================================= */
  /* 4. Carte Subjectif - ÉTAT ACTIF (Cyan/Blanc) */
  /* ================================================================= */
  .col-active.highlight {
      z-index: 10; transform: scale(1.05); 
      background-color: var(--primary) !important; border-color: var(--primary-deep) !important; 
      box-shadow: 0 10px 25px rgba(4, 171, 198, 0.3);
  }
  .col-active.highlight .col-title { color: #FFFFFF !important; border-bottom-color: rgba(255,255,255,0.3); }
  .col-active.highlight .val-big { color: #FFFFFF !important; }
  .col-active.highlight #disp_subjOD_va, .col-active.highlight #disp_subjOG_va { color: #FFFFFF !important; }
  .col-active.highlight .val-input { color: #FFFFFF !important; }

  /* ================================================================= */
  /* 5. ALIGNEMENTS */
  /* ================================================================= */
  .lbl { display: none !important; } 
  
  .col-title { 
      font-size: 0.8rem; font-weight: 800; text-transform: uppercase; margin-bottom: 8px; 
      border-bottom: 1px solid #F5F5F5; padding-bottom: 4px; width: 100%; white-space: nowrap;
  }
  .title-ra { color: var(--primary); }
  .title-subj { color: var(--primary-dark); font-size: 1rem; transition: color 0.2s; }
  
  /* Ajustement de la hauteur des lignes de données pour s'aligner aux cercles */
  .data-line { 
      display: flex; justify-content: center; align-items: center; 
      height: 34px; /* Hauteur identique aux cercles */
      margin-bottom: 2px; /* Marge identique aux cercles */
  }
  .val-input { font-family: 'Montserrat', sans-serif; }
  
  /* --- LETTRES (VERSION RÉDUITE) --- */
  /* --- LETTRES --- */
  .letter-display { 
      font-family: 'Segoe UI', sans-serif; 
      font-size: 3rem; /* RÉDUIT (était 5.5rem) */
      font-weight: bold; color: #263238; letter-spacing: 8px; 
      font-size: 3rem; 
      font-weight: bold; color: #3E2723; 
      letter-spacing: 8px; 
  }

  .info-bar { font-size: 1.1rem; color: var(--text-muted); margin-bottom: 15px; }
  .info-bar { font-size: 1.1rem; color: #8D6E63; margin-bottom: 15px; }

  /* STYLE DES PANNEAUX */
  .section { 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 8px; 
      padding: 10px; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  }

  h2 { 
      margin-top: 0; margin-bottom: 8px; 
      color: var(--primary-dark); 
      font-size: 1rem; 
      border-bottom: 1px solid var(--primary-border); 
      padding-bottom: 2px; 
  }

  .hidden { display: none !important; }

  /* INPUTS & RESUME */
  .summary-grid { display: grid; grid-template-columns: 1fr; gap: 5px; font-size: 0.95rem; }
  .summary-row { display: flex; justify-content: space-between; border-bottom: 1px solid #eee; padding: 4px 0; }
  .summary-lbl { color: var(--text-muted); font-weight: 600; }
  .summary-val { color: var(--primary-dark); font-weight: bold; }

  .config-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

  /* Grille compacte pour la section 2 */
  .mini-data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; text-align: center; }

  label { display: block; font-weight: 600; margin-bottom: 1px; font-size: 0.75rem; color: var(--text-muted); }
  input, select { 
      width: 100%; padding: 4px; 
      border: 1px solid #ccc; border-radius: 4px; 
      font-size: 0.9rem; background: #fff;
  }
  input:disabled, select:disabled { background-color: #F5F5F5; color: #888; border-color: #E0E0E0; }

  /* CHECKBOX ALIGNMENT */
  .check-grid { display:grid; grid-template-columns: 1fr 1fr; gap:5px; text-align: left; }
  .check-lbl { 
      display: flex; 
      align-items: center; 
      gap: 6px; 
      font-weight: normal; 
      color: var(--text-main); 
      font-size: 0.9rem;
      cursor: pointer;
      padding: 5px;
      border: 1px solid #eee;
      border-radius: 4px;
  }
  .check-lbl:hover { background: #f9f9f9; }
  .check-lbl input { width: auto; margin: 0; cursor: pointer; }

  /* --- COULEURS PERSONNALISÉES DES DONNÉES --- */

/* 1. Autoréfractomètre (RA) */
input[id^="ra"] {
    color: var(--primary); 
    background-color: transparent; 
    font-family: 'Montserrat', sans-serif;
    font-weight: 700;
    border: none; 
    text-align: center; 
    
    width: 100%;        /* <--- IMPORTANT : Prend la largeur de la colonne */
    font-size: 0.9rem;  /* <--- TAILLE RÉDUITE (était 1.1rem ou +) */
    padding: 2px 0;     /* Ajustement vertical */
}

/* Faites pareil pour input[id^="fronto"] juste en dessous */
input[id^="fronto"] {
    /* ... (mêmes propriétés de couleur) ... */
    width: 100%;
    font-size: 0.9rem;  /* <--- TAILLE RÉDUITE */
    padding: 2px 0;
}
  
  /* GRILLE VALEURS */
  .col-head { background: #ECEFF1; font-weight: bold; font-size: 0.7rem; padding: 4px 0; border-radius: 3px; }
  .col-input { padding: 3px; text-align: center; font-weight: 600; }
  .val-box { 
      background: var(--primary-light); color: var(--primary-dark);
      border: 1px solid var(--primary-border);
      font-weight: bold; font-size: 0.95rem; 
      display: flex; align-items: center; justify-content: center; 
      border-radius: 4px; min-height: 24px;
  }
  .col-max-va { background: #E8F5E9; color: #2E7D32; font-size: 0.8rem; border-color: #C8E6C9; }

  /* TITRES BLOCS DONNEES */
  .data-block-title {
      font-size: 0.75rem; font-weight:bold; color:var(--primary); text-align:center; 
      margin-bottom:3px; text-transform:uppercase; border-bottom:1px solid var(--primary-light);
  }




  /* MESSAGE BOX (CACHÉE) */
  .message-box { display: none !important; }
  .success-msg { background: #E0F2F1; color: #00695C; border-color: #B2DFDB; }

  /* BOUTONS REPONSE */
  .response-area { width: 100%; text-align: center; }

  .btn-grid { 
      display: flex; 
      justify-content: center; 
      gap: 40px; 
      flex-wrap: wrap; 
  }

  .btn-resp { 
      width: 80px; height: 80px;
      border-radius: 50%; border: none; 
      background: var(--primary-light); color: var(--primary-dark); 
      font-size: 2rem; 
      font-weight: bold; 
      cursor: pointer; transition: 0.2s; 
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  .btn-resp:hover { background: var(--primary); color: white; transform: scale(1.15); }

  .btn-resp.locked, .btn-action.locked, .btn-timer.locked, .btn-decision.locked {
      opacity: 0.5; cursor: wait; pointer-events: none;
  }

  /* ACTION BUTTONS */
  .btn-action { 
      padding: 15px 25px; border-radius: 8px; border: none; 
      color: white; font-weight: bold; cursor: pointer; 
      font-size: 1.1rem; margin-top: 10px; width: 100%;
      box-shadow: 0 3px 5px rgba(0,0,0,0.1);
      transition: background 0.2s;
  }

  .btn-start, .btn-validate, .btn-manual, .btn-rules { background: var(--primary); }
  .btn-start:hover, .btn-validate:hover { background: var(--primary-dark); }
  .btn-import { background: var(--primary-dark); }
  .btn-import:hover { background: var(--primary-deep); }

  /* --- Style spécifique pour GROSSIR les émojis --- */
  .emoji-icon {
      font-size: 3rem;        /* Taille géante pour l'émoji */
      vertical-align: middle; 
      margin-right: 15px;     /* Espace entre l'animal et le texte */
      line-height: 0;         /* Empêche l'émoji de déformer la hauteur */
      margin-top: -5px;       /* Petit ajustement vertical */
  }

  /* --- Ajustement du bouton pour accueillir l'émoji --- */
  .btn-tortue, .btn-lapin {
      background: var(--primary-light); 
      color: var(--primary-dark); 
      border: 2px solid var(--primary-border);
      
      font-size: 1.3rem;      /* Taille normale pour le texte */
      padding: 0 40px;        /* Padding horizontal */
      
      /* Flexbox pour aligner l'émoji et le texte */
      display: flex !important;
      align-items: center;
      justify-content: center;
      
      height: 80px;           /* Hauteur fixe pour que ça reste propre */
  }

  .btn-tortue:hover, .btn-lapin:hover { 
      background: var(--primary); 
      color: white; 
  }
  /* PROFIL */
  .force-profile-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 15px; }
  .btn-profile { padding: 8px; color: white; border: none; border-radius: 4px; font-size: 0.9rem; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  .p-green { background: #26A69A; } .p-blue { background: #42A5F5; }
  .p-orange { background: #FFA726; } .p-red { background: #EF5350; }

  /* BOUTONS EXAMEN */
  .btn-timer { 
      background: var(--primary); color: white; padding: 15px 35px; font-size: 1.2rem; 
      border-radius: 40px; border:none; cursor: pointer; margin-bottom: 15px;
  }
  .btn-timer:hover { background: var(--primary-dark); }
  .decision-row { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; }
  .btn-decision { padding: 12px 25px; border-radius: 8px; border: none; color: white; font-weight: bold; cursor: pointer; font-size: 1.1rem; }
  .btn-blue { background: var(--primary); } 
  .btn-orange { background: var(--primary-dark); } 
  .btn-red { background: var(--primary-deep); } 
  .btn-green { background: var(--primary); } 
  .btn-grey { background: var(--primary-light); color: var(--primary-dark); border: 1px solid var(--primary-border); }
  .btn-grey:hover { background: var(--primary-border); }

  /* RESPONSIVE */
  @media (max-width: 900px) {
      body { overflow: auto; height: auto; } 
      .app-container { height: auto; display: block; }
      .dashboard-wrapper { display: block; } 
      .left-panel { width: 100%; margin-bottom: 15px; }
      .right-panel { min-height: 400px; }
  }

  /* MODAL */
  .modal-overlay { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(55, 71, 79, 0.9); z-index: 9999; 
      display: flex; justify-content: center; align-items: center; 
  }
  .modal-content { background: #fff; padding: 30px; border-radius: 12px; width: 90%; max-width: 600px; text-align: center; }
  .modal-text { font-size: 1.2rem; line-height: 1.5; margin-bottom: 25px; color: var(--text-main); }

  /* Visual JCC */
  /* --- NOUVEAU STYLE AXE (JCC) ALIGNÉ SUR LES BULLES --- */

/* Conteneur pour centrer les cercles 1 et 2 dans le schéma */
#schemaContainer .jcc-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    gap: 120px; /* Écarte les cercles pour laisser respirer le centre */
    width: 100%;
    pointer-events: none; /* L'animation ne doit pas gêner les clics */
    z-index: 300;
}

/* --- SÉCURITÉ DISPARITION JCC --- */
#jccVisuals.hidden {
    display: none !important;
    opacity: 0;
    pointer-events: none;
}
  
/* Style "Bulle" identique au test de sphère */
/* --- Modif JCC Visuals --- */
/* --- VISUELS JCC (CORRIGÉS) --- */
/* --- VISUELS JCC AFFINÉS --- */

.jcc-visual {
    width: 95px;
    height: 95px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.05);
    /* Bordure grise visible quand inactive */
    border: 2px solid rgba(150, 150, 150, 0.4); 
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.4s ease-in-out;
    position: relative;
    opacity: 0.5; /* Transparent avant le test */
}

/* --- LE MOTEUR DE ROTATION --- */
/* 1. Moteur de rotation stable */
/* 1. Moteur de rotation sans décalage */
/* --- VISUELS JCC : STYLE DES BULLES & ANIMATION --- */

@keyframes spin-arrow {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* La bulle par défaut (éteinte) */
.jcc-visual {
    width: 95px;
    height: 95px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.05); /* Très transparent */
    border: 2px solid rgba(150, 150, 150, 0.4); 
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    opacity: 0.5;
    transition: all 0.4s ease-in-out; /* Pour un allumage fluide */
}

/* LA BULLE ACTIVE (L'EFFET GLOW & ZOOM) */
.jcc-visual.active {
    background: #FFFFFF !important;
    opacity: 1 !important;
    transform: scale(1.05); /* Effet zoom léger */
    border-color: #04ABC6;
    border-width: 3px;
    /* Effet d'illumination (Glow) */
    box-shadow: 0 0 20px rgba(4, 171, 198, 0.6), 0 0 40px rgba(4, 171, 198, 0.2);
}

/* LES CHIFFRES GÉANTS */
.jcc-label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4rem; /* Augmenté pour être géant */
    font-weight: 900;
    font-family: 'Montserrat', sans-serif;
    color: #04ABC6 !important;
    z-index: 2; /* Devant la flèche */
    line-height: 1;
    margin: 0;
}

/* LA FLÈCHE (STABLE) */
.arrow-svg {
    width: 95px;
    height: 95px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform-origin: center center;
    transform: translate(-50%, -50%);
    z-index: 1; /* Derrière le chiffre */
    overflow: visible;
}

.jcc-visual.active .arrow-svg {
    animation: spin-arrow 2.5s linear infinite;
}

#visPos1.active .arrow-svg {
    animation-direction: reverse;
}
  /* INPUTS MODAL */
  .modal-input-grid {
      display: flex;
      flex-direction: column; 
      gap: 10px;
      text-align: left;
      margin-bottom: 20px;
  }
  .modal-input-group label {
      display: block;
      margin-bottom: 3px;
      color: var(--text-muted);
      font-size: 0.85rem;
  }
  .modal-input-group input {
      font-size: 1.1rem;
      padding: 6px;
      text-align: center;
      border: 1px solid var(--primary-border);
      width: 100%;
  }
  .modal-eye-title {
      text-align: center;
      font-weight: bold;
      color: var(--primary-dark);
      margin-bottom: 10px;
      border-bottom: 2px solid var(--primary-light);
      padding-bottom: 5px;
      font-size: 1.1rem;
  }
  .device-header {
      font-weight: 700; color: var(--primary); margin-bottom: 15px; text-transform: uppercase; font-size: 1.1rem; text-align: center;
  }
  .data-source-lbl {
      font-weight: 600; color: var(--primary-dark); margin-bottom: 5px; margin-top: 15px; display: block;
  }

  /* --- STYLE TEST DE SCHOBER --- */
  .schober-container { display: flex; flex-direction: column; gap: 15px; width: 100%; align-items: center; border: 1px solid #ECEFF1; padding: 10px; border-radius: 8px; margin-bottom: 15px; }
  .schober-group-title { font-weight: bold; font-size: 1rem; color: var(--primary-deep); text-transform: uppercase; margin-bottom: 15px; border-bottom: 2px solid var(--primary-light); display: inline-block; padding-bottom: 5px; }

  /* Nouveaux styles pour les sous-catégories */
  .schober-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; width: 100%; }
  .schober-sub-group { display: flex; flex-direction: column; align-items: center; background: #FAFAFA; padding: 10px; border-radius: 8px; border: 1px solid #eee; }
  .schober-sub-title { font-size: 0.8rem; font-weight: 700; color: #00838F; margin-bottom: 10px; text-align: center; max-width: 140px; min-height: 30px; display:flex; align-items:center; justify-content:center; }

  .schober-grid { display: flex; justify-content: center; gap: 10px; }

  .btn-schober { width: 90px; height: 90px; background-color: #000000; border: 3px solid #455A64; border-radius: 12px; cursor: pointer; position: relative; display: flex; justify-content: center; align-items: center; transition: transform 0.2s, border-color 0.2s; }
  .btn-schober:hover { transform: scale(1.05); border-color: var(--primary); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }

  /* SVG Styles */
  .sch-cross { stroke: #FF0000; stroke-width: 4; }
  .sch-circle { stroke: #00FF00; stroke-width: 4; fill: none; }
  .sch-faint { opacity: 0.3; stroke-dasharray: 4; }

  .step-instruction { font-size: 1.2rem; color: var(--text-main); margin-bottom: 25px; text-align: center; background: #E1F5FE; padding: 15px; border-radius: 8px; border-left: 5px solid var(--primary); }

/* --- CORRECTION Z-INDEX MODALES --- */
/* Force les modales à être TOUJOURS au-dessus du Schober (qui est à 9999) */
.modal-overlay {
    z-index: 20000 !important; 
}  

/* --- SÉCURITÉ AFFICHAGE COLONNE CENTRALE --- */
.center-labels {
    display: flex !important; /* Force l'affichage même si caché ailleurs */
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    width: 60px;
    margin: 0 5px;
    padding-top: 5px;
    background: transparent;
}

.center-labels .col-title {
    height: 20px;
    margin-bottom: 8px;
    visibility: hidden;
}

.center-labels .label-row {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    margin-top: 2px;
    margin-bottom: 2px;
    border-radius: 50%;
    
    /* VOS COULEURS : Fond Crème, Bordure Cyan 4px */
    background-color: #FCF9F2;
    border: 4px solid #04ABC6; 
    color: #04ABC6;
    
    font-weight: 800;
    font-family: 'Montserrat', sans-serif;
    font-size: 1.1rem;
}  

/* --- BOUTON ALÉATOIRE (SHUFFLE) --- */
#btnRandomLetters {
    /* PLACEMENT GRILLE : Juste à droite de zoneLettres (qui finit col 19) */
    grid-column: 19 / 21; 
    /* Centré verticalement par rapport à zoneLettres (lignes 9-15) */
    grid-row: 11 / 13;    
    
    /* ESTHÉTIQUE */
    background-color: #04ABC6; /* Bleu Cyan */
    border: 3px solid #026070; /* Bleu plus foncé */
    border-radius: 50%;        /* Rond parfait */
    
    width: 60px;
    height: 60px;
    
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: transform 0.2s, background 0.2s;
    
    /* S'assure qu'il est au dessus */
    z-index: 50;
    margin: auto; /* Centrage dans sa case de grille */
}

#btnRandomLetters:hover {
    transform: scale(1.1) rotate(180deg); /* Petit effet de rotation sympa */
    background-color: #03889E;
}

#btnRandomLetters:active {
    transform: scale(0.95);
}

#btnRandomLetters svg {
    width: 30px;
    height: 30px;
    fill: none;
    stroke: white;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
}
/* ========================================================= */
/* 1. ANIMATION SCHÉMA SPHERE (VERSION FINALE)               */
/* ========================================================= */

#schemaContainer {
    grid-column: 1 / 13; 
    grid-row: 14 / 17; /* Position remontée */
    
    display: flex; justify-content: center; align-items: center;
    position: relative; background: transparent;
    z-index: 200; pointer-events: none;
}

/* Style des bulles */
.anim-bubble {
    width: 90px; height: 90px;
    border-radius: 50%;
    display: flex; justify-content: center; align-items: center; text-align: center;
    font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 0.9rem; line-height: 1.2;
    padding: 5px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

/* CERCLE BLEU (BASE) - Fixe au centre */
.bubble-base {
    background: #E0F7FA; border: 3px solid #04ABC6; color: #006064;
    z-index: 10;
    opacity: 0; transform: scale(0.8);
    transition: opacity 0.5s, transform 0.5s;
}
.bubble-base.visible { opacity: 1; transform: scale(1); }

/* --- GAUCHE (+0.25) --- */
.arrow-connector {
    position: absolute; right: 50%; margin-right: 44px;
    height: 6px; background-color: #04ABC6; width: 0px; 
    transition: width 0.4s ease-out; z-index: 5;
}
.arrow-connector::before {
    content: ''; position: absolute; left: -8px; top: -5px; width: 0; height: 0;
    border-top: 8px solid transparent; border-bottom: 8px solid transparent; 
    border-right: 12px solid #04ABC6; opacity: 0; transition: opacity 0.2s;
}
.arrow-connector.active { width: 100px; }
.arrow-connector.active::before { opacity: 1; }

.bubble-target {
    position: absolute; background: #E8F5E9; border: 3px solid #43A047; color: #1B5E20;
    z-index: 6; right: 50%; margin-right: 45px; 
    opacity: 0; transform: scale(0.5); transition: all 0.4s ease-out;
}
.bubble-target.visible { opacity: 1; transform: translateX(-110px) scale(1); }

/* --- DROITE (-0.25) --- */
.arrow-connector-right {
    position: absolute; left: 50%; margin-left: 44px;
    height: 6px; background-color: #04ABC6; /* TIGE BLEUE */
    width: 0px; transition: width 0.4s ease-out; z-index: 5;
    top: 50%; transform: translateY(-50%);
}
.arrow-connector-right::before {
    content: ''; position: absolute; right: -8px; top: -5px; width: 0; height: 0;
    border-top: 8px solid transparent; border-bottom: 8px solid transparent; 
    border-left: 12px solid #04ABC6; /* POINTE BLEUE */
    opacity: 0; transition: opacity 0.2s;
}
.arrow-connector-right.active { width: 100px; }
.arrow-connector-right.active::before { opacity: 1; }

.bubble-target-minus {
    position: absolute; background: #FFEBEE; border: 3px solid #D32F2F; color: #B71C1C;
    z-index: 6; left: 50%; margin-left: 45px; top: 54%; 
    opacity: 0; transform: translate(-50%, -50%) scale(0.5); transition: all 0.4s ease-out;
}
.bubble-target-minus.visible { opacity: 1; transform: translate(110px, -50%) scale(1); }


/* ========================================================= */
/* 2. STYLE BIO-MONOCULAIRE (Oeil Passif)                    */
/* ========================================================= */
.exam-data-strip .col-bio-inactive {
    background: rgba(4, 171, 198, 0.1) !important; 
    border-color: rgba(4, 171, 198, 0.4) !important; 
    transform: scale(1) !important; opacity: 0.9;
}
.exam-data-strip .col-bio-inactive .val-big,
.exam-data-strip .col-bio-inactive .col-title,
.exam-data-strip .col-bio-inactive .val-input,
.exam-data-strip .col-bio-inactive span {
    color: #00838F !important; 
}

/* ========================================================= */
/* === NOUVEAUX BOUTONS & STYLE RETESTER (FINAL) ===         */
/* ========================================================= */

/* 1. Z-INDEX PARENT (CRUCIAL) */
#zoneBoutons {
    z-index: 500 !important;
    position: relative;
}

/* 2. Conteneur principal (Hauteur ajustée -85px) */
#checkPlusZone {
    position: relative;
    width: 100%;
    margin-top: -127px; 
    pointer-events: auto;
    z-index: 600 !important;
}

/* Ligne des boutons (Alignement haut) */
.decision-row-round {
    display: flex;
    justify-content: center;
    align-items: flex-start; 
    gap: 30px;
    width: 100%;
    position: relative;
    padding-top: 10px;
}

/* 3. Style des Boutons Ronds (Base 90px) */
.btn-round {
    width: 90px; height: 90px;
    border-radius: 50%;
    font-family: 'Montserrat', sans-serif;
    font-weight: 700;
    font-size: 0.8rem;
    line-height: 1.1;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.15);
    transition: transform 0.2s;
    border: none;
    display: flex; justify-content: center; align-items: center; text-align: center;
    flex-shrink: 0;
}
.btn-round:hover { transform: scale(1.05); }
.btn-round:active { transform: scale(0.95); }

/* --- COULEURS --- */
.btn-round-green { background: #43A047; color: white; border: 2px solid #2E7D32; }
.btn-round-red   { background: #EF5350; color: white; border: 2px solid #C62828; }
.btn-round-blue  { background: #E0F7FA; color: #006064; border: 3px solid #04ABC6; }
.btn-round-outline { background: transparent; color: #00838F; border: 2px solid #04ABC6; }

/* 4. NOUVEAU STYLE : BOUTON RETESTER (Rond et Gris) */
.btn-round-grey { 
    background: #ECEFF1; 
    color: #546E7A; 
    border: 2px solid #CFD8DC; 
}
.btn-round-grey:hover { background: #CFD8DC; }

/* 5. COLONNE VERTICALE (ESPACEMENT) */
.btn-col-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    
    /* Espace vertical entre le bouton bleu et Retester */
    gap: 25px; 
    
    width: 90px; 
}

/* 6. DÉCALAGES PRÉCIS */
#decisionsPlus { transform: translateX(-401px); }
#decisionsMinus { transform: translateX(-161px); }

/* --- AJOUT POUR LA VISIBILITÉ DE L'AXE --- */

/* On s'assure que les boutons de l'axe sont bien visibles */
/* --- STYLE FINAL DES BOUTONS DE RÉPONSE AXE (JCC) --- */

/* --- BOUTONS RÉPONSE AXE (JCC) REPOSITIONNÉS ET RÉDUITS --- */
#axisControls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    margin-top: 20px;
}

#axisDecisions {
    display: flex;
    gap: 20px;
    justify-content: center;
}

/* Style des 3 boutons de choix (Mieux 1, Mieux 2, Pareil) */
#axisDecisions .btn-decision {
    width: 65px !important;
    height: 65px !important;
    min-width: 65px !important;
    border-radius: 50% !important;
    background: #FFFFFF !important;
    font-family: 'Montserrat', sans-serif;
    font-weight: 800;
    font-size: 0.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    line-height: 1.2;
    text-transform: uppercase;
    transition: all 0.2s ease;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

/* Style spécifique du bouton RÉPÉTER (RETESTER) */
#btnReplayAxis {
    width: 65px !important;
    height: 65px !important;
    border-radius: 50% !important;
    background: #ECEFF1 !important; /* Gris clair comme les autres retester */
    color: #546E7A !important;
    border: 2px solid #CFD8DC !important;
    font-family: 'Montserrat', sans-serif;
    font-weight: 700;
    font-size: 0.75rem;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
}

#axisDecisions .btn-blue { border: 4px solid #116dff !important; color: #116dff !important; }
#axisDecisions .btn-orange { border: 4px solid #fd7e14 !important; color: #fd7e14 !important; }
#axisDecisions .btn-green { border: 4px solid #43A047 !important; color: #43A047 !important; }

#axisDecisions .btn-decision:hover, #btnReplayAxis:hover {
    transform: scale(1.05);
}  

/* --- SÉCURITÉ ANTI-CLIGNOTEMENT (RADICALE) --- */
/* On neutralise tous les effets de survol et d'ombre quand la classe 'locked' est présente */
.btn-resp.locked, .btn-action.locked, .btn-timer.locked, .btn-decision.locked {
    pointer-events: none !important;
    cursor: default !important;
    transform: none !important;
    opacity: 0.5 !important;
    box-shadow: none !important;
    transition: none !important;
}
/* On force l'état bloqué même si la souris survole le bouton */
.btn-resp.locked:hover, .btn-action.locked:hover {
    background: var(--primary-light) !important; /* Reste en couleur pâle */
    color: var(--primary-dark) !important;
    transform: none !important;
}
  
</style>
</head>
<body onload="window.startAppSequence()">

<div id="modalPatientID" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Identification du Patient</h2>
        <div class="config-grid" style="text-align:left; margin: 20px 0;">
            <div><label>Nom</label><input type="text" id="inName"></div>
            <div><label>Prénom</label><input type="text" id="inForename"></div>
            <div><label>Date Naiss.</label><input type="date" id="inDob"></div>
            <div><label>UID</label><input type="text" id="inUID" readonly style="background:#ECEFF1; color:var(--primary-dark); font-weight:bold; cursor:not-allowed;"></div>
        </div>
        <button class="btn-action btn-validate" style="width:auto; padding:15px 40px; font-size:1.1rem; border-radius:50px;" onclick="window.validatePatientID()">VALIDER</button>
    </div>
</div>

<div id="modalProfileCalc" class="modal-overlay hidden">
    <div class="modal-content" style="max-width: 900px;">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Profil Accommodatif</h2>

        <div class="config-grid" style="text-align:left; margin-bottom:15px;">
            <div>
                <label>Rythme des consultations par année</label>
                <select id="inRhythm"><option value="0">...</option><option value="1">1x/an</option><option value="2">1x/2ans</option><option value="3">< 1x/2ans</option></select>
            </div>
            <div>
                <label>Nombres de signes de décompensation de phorie par mois</label>
                <select id="inSigns"><option value="0">0</option><option value="2">3-4</option><option value="3">> 4</option></select>
            </div>
        </div>

        <div class="check-grid" style="margin-bottom:20px;">
            <label class="check-lbl"><input type="checkbox" id="chkMyopia" onchange="window.toggleMyopiaHyper('myopia')"> Myopie > 3 dioptries</label>
            <label class="check-lbl"><input type="checkbox" id="chkHyper" onchange="window.toggleMyopiaHyper('hyper')"> Hypermétropie < 1 dioptrie</label>
            <label class="check-lbl"><input type="checkbox" id="chkNear"> Habitudes de près</label>
            <label class="check-lbl"><input type="checkbox" id="chkNoSpecs"> Lunettes Mal ou non portées</label>
            <label class="check-lbl"><input type="checkbox" id="chkMono"> Monophtalme</label>
        </div>

        <button class="btn-action btn-start" style="padding:15px; font-size:1.1rem;" onclick="window.calculateProfileAndShowData()">CALCUL DU PROFIL ACCOMMODATIF</button>

        <div style="text-align:center; margin:15px 0 5px 0; color:var(--text-muted); font-size:0.9rem;">Ou forcer le profil :</div>
        <div class="force-profile-row">
            <button id="btnProfile1" class="btn-profile p-green" onclick="window.forceProfileAndShowData('1')">Bon (1)</button>
            <button class="btn-profile p-blue" onclick="window.forceProfileAndShowData('2')">Moyen</button>
            <button class="btn-profile p-orange" onclick="window.forceProfileAndShowData('3')">Difficile</button>
            <button class="btn-profile p-red" onclick="window.forceProfileAndShowData('3+')">Très Diff.</button>
        </div>
    </div>
</div>

<div id="modalEntryMethod" class="modal-overlay hidden">
    <div class="modal-content" style="max-width:500px;">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Saisie des Données</h2>
        <div class="modal-text">Sélectionnez l'appareil à renseigner :</div>

        <div style="display:flex; flex-direction:column; gap:15px;">
            <button class="btn-action btn-manual" style="background:#FFF; color:var(--primary-dark); border:2px solid var(--primary-border);" onclick="window.openModal('AutoRef')">
                <strong>AUTO-RÉFRACTOMÈTRE (RA)</strong><br>
                <span style="font-size:0.8rem;">Saisie Sphère / Cyl / Axe</span>
            </button>

            <button class="btn-action btn-manual" style="background:#FFF; color:#546E7A; border:2px solid #CFD8DC;" onclick="window.openModal('Fronto')">
                <strong>FRONTOFOCOMÈTRE</strong><br>
                <span style="font-size:0.8rem;">Lunettes portées</span>
            </button>

            <div style="height:1px; background:#eee; margin:10px 0;"></div>

            <button class="btn-action btn-import" onclick="window.simulateImport()">
                Importer depuis les appareils (Simul.)
            </button>

            <button class="btn-action btn-validate" style="margin-top:10px;" onclick="window.finishDataEntry()">
                TERMINER LA SAISIE
            </button>
        </div>
    </div>
</div>
<div id="modalInputAutoRef" class="modal-overlay hidden">
    <div class="modal-content" style="max-width: 600px;">
        <h2 style="color:var(--primary); border:none;">Auto-Réfractomètre (RA)</h2>

        <div style="display:flex; gap:20px; margin-bottom:20px;">
            <div style="flex:1;">
                <div class="modal-eye-title">ŒIL DROIT</div>
                <div class="modal-input-grid">
                    <div class="modal-input-group"><label>Sphère</label><input type="text" id="mod_raOD_sph" placeholder="+/- 0.00" inputmode="decimal" onchange="window.checkSphere(this)"></div>
                    <div class="modal-input-group"><label>Cylindre</label><input type="text" id="mod_raOD_cyl" placeholder="- 0.00" inputmode="decimal" onchange="window.checkCylInput(this)"></div>
                    <div class="modal-input-group"><label>Axe</label><input type="text" id="mod_raOD_axe" placeholder="0°" inputmode="decimal" onchange="window.checkAxis(this)"></div>
                </div>
            </div>
            <div style="flex:1;">
                <div class="modal-eye-title">ŒIL GAUCHE</div>
                <div class="modal-input-grid">
                    <div class="modal-input-group"><label>Sphère</label><input type="text" id="mod_raOG_sph" placeholder="+/- 0.00" inputmode="decimal" onchange="window.checkSphere(this)"></div>
                    <div class="modal-input-group"><label>Cylindre</label><input type="text" id="mod_raOG_cyl" placeholder="- 0.00" inputmode="decimal" onchange="window.checkCylInput(this)"></div>
                    <div class="modal-input-group"><label>Axe</label><input type="text" id="mod_raOG_axe" placeholder="0°" inputmode="decimal" onchange="window.checkAxis(this)"></div>
                </div>
            </div>
        </div>

        <button class="btn-action btn-validate" onclick="window.saveAndCloseModal('AutoRef')">VALIDER RA</button>
    </div>
</div>

<div id="modalInputFronto" class="modal-overlay hidden">
    <div class="modal-content" style="max-width: 600px;">
        <h2 style="color:#546E7A; border:none;">Frontofocomètre</h2>

        <div style="display:flex; gap:20px; margin-bottom:20px;">
            <div style="flex:1;">
                <div class="modal-eye-title" style="color:#546E7A; border-color:#CFD8DC;">ŒIL DROIT</div>
                <div class="modal-input-grid">
                    <div class="modal-input-group"><label>Sphère</label><input type="text" id="mod_frontoOD_sph" placeholder="+/- 0.00" inputmode="decimal" onchange="window.checkSphere(this)"></div>
                    <div class="modal-input-group"><label>Cylindre</label><input type="text" id="mod_frontoOD_cyl" placeholder="- 0.00" inputmode="decimal" onchange="window.checkCylInput(this)"></div>
                    <div class="modal-input-group"><label>Axe</label><input type="text" id="mod_frontoOD_axe" placeholder="0°" inputmode="decimal" onchange="window.checkAxis(this)"></div>
                </div>
            </div>
            <div style="flex:1;">
                <div class="modal-eye-title" style="color:#546E7A; border-color:#CFD8DC;">ŒIL GAUCHE</div>
                <div class="modal-input-grid">
                    <div class="modal-input-group"><label>Sphère</label><input type="text" id="mod_frontoOG_sph" placeholder="+/- 0.00" inputmode="decimal" onchange="window.checkSphere(this)"></div>
                    <div class="modal-input-group"><label>Cylindre</label><input type="text" id="mod_frontoOG_cyl" placeholder="- 0.00" inputmode="decimal" onchange="window.checkCylInput(this)"></div>
                    <div class="modal-input-group"><label>Axe</label><input type="text" id="mod_frontoOG_axe" placeholder="0°" inputmode="decimal" onchange="window.checkAxis(this)"></div>
                </div>
            </div>
        </div>

        <button class="btn-action btn-validate" style="background:#546E7A;" onclick="window.saveAndCloseModal('Fronto')">VALIDER FRONTO</button>
    </div>
</div>

<div id="modalHandedness" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Latéralité</h2>
        <div class="modal-text">Le patient est-il droitier ou gaucher ?</div>
        <div style="display:flex; gap:20px; justify-content:center;">
            <button class="btn-action btn-validate" style="width:auto; padding:15px 30px;" onclick="window.setHandedness('OD')">DROITIER</button>
            <button class="btn-action btn-validate" style="width:auto; padding:15px 30px;" onclick="window.setHandedness('OG')">GAUCHER</button>
        </div>
    </div>
</div>

<div id="modalSchoberQuestion" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Réponse du patient ?</h2>
        <div class="modal-text" style="font-size:1.2rem; margin-bottom:30px;">
            A-t-il répondu <strong>OUI</strong> ?<br>
            <span style="font-size:0.9rem; color:#78909C;">(Voit-il la croix ET le cercle ?)</span>
        </div>
        <div style="display:flex; gap:20px; justify-content:center;">
            <button class="btn-action btn-grey" style="width:auto; padding:15px 40px; font-size:1.2rem;" onclick="window.handleSchoberAnswer('non')">NON</button>
            <button class="btn-action btn-validate" style="width:auto; padding:15px 40px; font-size:1.2rem;" onclick="window.handleSchoberAnswer('oui')">OUI</button>
        </div>
    </div>
</div>
  
<div id="modalSchoberConfirm" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Confirmation Schober</h2>
        <div id="schoberConfirmText" class="modal-text" style="font-weight:500; color:#37474F; margin-bottom:25px;"></div>
        <div style="display:flex; gap:20px; justify-content:center;">
            <button class="btn-action btn-grey" style="width:auto; padding:15px 30px;" onclick="window.cancelSchober()">ANNULER</button>
            <button class="btn-action btn-validate" style="width:auto; padding:15px 30px;" onclick="window.validateSchober()">VALIDER</button>
        </div>
    </div>
</div>

<div id="modalPosition" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Installation</h2>
        <div class="modal-text">
            Placez le patient derrière la tête du réfracteur en veillant à ce qu’il soit confortablement installé : son front doit être bien apposé contre l’appui-front, et ses yeux parfaitement centrés dans les oculaires.
            <br><br>
            Assurez-vous également que ses joues ne soient pas en contact avec l’appareil — il doit être possible de glisser un doigt entre ses joues et le réfracteur.
        </div>
        <button class="btn-action btn-rules" style="width:auto; padding:15px 40px; font-size:1.1rem; border-radius:50px;" onclick="window.startRulesAndIntro()">RÈGLES DE LECTURE</button>
    </div>
</div>

<div id="modalIntroConfirmation" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary); border:none; font-size:1.6rem;">Prêt à commencer ?</h2>
        <div class="modal-text">
            Assurez-vous que le patient a bien compris les règles de lecture que vous venez de lui expliquer.
            <br><br>
            Si c'est le cas, vous pouvez commencer l'examen.
        </div>
        <button class="btn-action btn-validate" style="width:auto; padding:15px 40px; border-radius:50px; font-size:1.1rem;" onclick="window.confirmAndLaunch()">LANCER L'EXAMEN</button>
    </div>
</div>

<div id="modalWarning" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary-deep); border:none; font-size:1.6rem;">Hors Limites</h2>
        <div class="modal-text">La valeur saisie est hors des limites de l’appareil. Merci de la corriger.</div>
        <button class="btn-action btn-validate" style="width:auto; padding:15px 40px; border-radius:50px;" onclick="window.closeWarningModal()">CORRIGER</button>
    </div>
</div>

  <div id="modalCylTranspose" class="modal-overlay hidden">
    <div class="modal-content" style="border-top: 5px solid #FFA726; max-width: 500px;">
        <h2 style="color:#EF6C00; border:none; font-size:1.4rem; margin-top:0;">Cylindre Positif Détecté</h2>
        <div class="modal-text" style="text-align:left; font-size:1rem; color:#333;">
            Vous avez saisi une valeur positive : <strong><span id="txtPosCylVal" style="color:#D84315;"></span></strong>.<br><br>
            Ce logiciel fonctionne exclusivement en <strong>cylindre négatif</strong>.<br>
            Que souhaitez-vous faire ?
        </div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:20px;">
            <button class="btn-action btn-validate" style="background:#0277BD; border-radius:6px; padding:12px;" onclick="window.applyTransposition()">
                <strong>TRANSPOSER LA FORMULE</strong><br>
                <span style="font-size:0.8rem; opacity:0.9;">(Recalcule Sphère et Axe mathématiquement)</span>
            </button>
            <button class="btn-action btn-grey" style="border-radius:6px; padding:12px;" onclick="window.invertCylSign()">
                <strong>JUSTE INVERSER LE SIGNE (+ vers -)</strong><br>
                <span style="font-size:0.8rem; color:#666;">(Si c'est une erreur de frappe)</span>
            </button>
            <button class="btn-action btn-grey" style="background:#fff; border:1px solid #ccc; color:#555; border-radius:6px; padding:10px;" onclick="window.cancelCorrection()">
    Annuler / Corriger manuellement
</button>
        </div>
    </div>
</div>
<div id="modalAskAxis" class="modal-overlay hidden">
    <div class="modal-content" style="border-top: 5px solid #FFA726; max-width: 450px;">
        <h2 style="color:#EF6C00; border:none; font-size:1.4rem;">Axe Manquant</h2>

        <div class="modal-text" style="text-align:left;">
            Pour transposer mathématiquement le cylindre positif, il faut connaître son axe d'origine.<br><br>
            <span style="color:#D84315; font-weight:bold;">👉 Entrez l'axe du cylindre POSITIF :</span>
        </div>

        <div style="margin: 20px 0;">
            <input type="number" id="inputTranspAxis" placeholder="Ex: 90" 
                   style="font-size:1.5rem; padding:10px; width:150px; text-align:center; border:2px solid #FFA726; border-radius:8px; font-weight:bold;">
            <div style="font-size:0.8rem; color:#888; margin-top:5px;">(Entre 0 et 180°)</div>
        </div>

        <div style="display:flex; gap:15px; justify-content:center;">
            <button class="btn-action btn-grey" style="width:auto;" onclick="window.closeAskAxisModal()">Annuler</button>
            <button class="btn-action btn-validate" style="width:auto; background:#EF6C00;" onclick="window.validateTranspositionAxis()">VALIDER</button>
        </div>
    </div>
</div>
  <div id="modalDefogLimit" class="modal-overlay hidden">
    <div class="modal-content" style="max-width:700px;">
        <h2 style="color:#D32F2F; border:none; font-size:1.6rem;">⚠️ Votre attention, s'il vous plaît !</h2>
        <div class="modal-text" style="text-align:left; font-size:1rem;">
            <strong>Absence d'amélioration de l'acuité visuelle après plusieurs débrouillages.</strong><br><br>
            Vous avez effectué plusieurs étapes de débrouillage sans gain significatif d'acuité visuelle.<br><br>
            Rappel : Répétez vos directives au patient, vérifiez sa position, nettoyez les lentilles et confirmez les données de l'AR.<br><br>
            Nous vous recommandons de recommencer l'examen selon l'une des options suivantes :
        </div>
        <div id="defogButtons" style="display:flex; flex-direction:column; gap:10px; margin-top:20px;">
            <button class="btn-action btn-grey" style="white-space:normal; height:auto; padding:10px; text-align:left;" onclick="window.restartExam()">Le patient n'avait pas bien compris...</button>
            <button class="btn-action btn-validate" style="background:#D32F2F; white-space:normal; height:auto; padding:10px; text-align:left;" onclick="window.prepareCycloStop()">Le patient avait bien compris...</button>
        </div>
        <div id="saveCycloContainer" class="hidden" style="margin-top:20px;"><button class="btn-action btn-validate" style="padding:15px 30px;" onclick="window.savePatientData()">Sauvegarder les données</button></div>
    </div>
</div>

<div id="modalTqsLimit" class="modal-overlay hidden">
    <div class="modal-content" style="max-width:700px;">
        <h2 style="color:#D32F2F; border:none; font-size:1.6rem;">⚠️ Votre attention, s'il vous plaît !</h2>
        <div class="modal-text" style="text-align:left; font-size:1rem;">
            <strong>Vous venez de brouiller de plus de 1.00 D sur la ligne de 6/10.</strong><br><br>
            Vous avez effectué plusieurs étapes de brouillage sans pouvoir bloquer l'accommodation du patient.<br><br>
            Rappel : Répétez vos directives au patient. Il est possible qu'il n'ai pas relu les lettres mais qu'il vous les a répété de mémoire. Vérifiez également sa position, il regarde peut-être en dehors des oculaires.<br><br>
            Nous vous recommandons de recommencer l'examen selon l'une des options suivantes :
        </div>
        <div id="tqsButtons" style="display:flex; flex-direction:column; gap:10px; margin-top:20px;">
            <button class="btn-action btn-grey" style="white-space:normal; height:auto; padding:10px; text-align:left;" onclick="window.restartExam()">Le patient n'avait pas bien compris...</button>
            <button class="btn-action btn-validate" style="background:#D32F2F; white-space:normal; height:auto; padding:10px; text-align:left;" onclick="window.prepareCycloStopTqs()">Le patient avait bien compris...</button>
        </div>
        <div id="saveCycloContainerTqs" class="hidden" style="margin-top:20px;"><button class="btn-action btn-validate" style="padding:15px 30px;" onclick="window.savePatientData()">Sauvegarder les données</button></div>
    </div>
</div>

<div id="modalIncoherent" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 style="color:var(--primary-deep); border:none; font-size:1.6rem;">Réponse Incohérente</h2>
        <div class="modal-text">Le patient vient de vous donner une réponse incohérente. Il faut refaire cette partie de l'examen.</div>
        <button class="btn-action btn-validate" style="width:auto; padding:15px 40px; border-radius:50px;" onclick="window.restartSb10()">RECOMMENCER CETTE PARTIE DE L'EXAMEN</button>
    </div>
</div>


    <div id="modalAxeSecurity" class="modal-overlay hidden">
        <div class="modal-content" style="border-top: 5px solid #04ABC6; max-width: 500px;">
            <h2 style="color:var(--primary-dark); border:none;">⚠️ Axe sans Cylindre</h2>
            <div class="modal-text" style="text-align:left;">
                Vous avez saisi un axe (<span id="txtOrphanAxe" style="font-weight:bold;"></span>°) pour l'œil <span id="txtOrphanEye" style="font-weight:bold;"></span>, mais la puissance du cylindre est à 0.00.
                <br><br>
                Que souhaitez-vous faire ?
            </div>
            <div style="display:flex; flex-direction:column; gap:12px; margin-top:20px;">
                <button class="btn-action btn-validate" onclick="window.backToCylEntry()">RETOURNER SAISIR LE CYLINDRE</button>
                <button class="btn-action btn-grey" style="background:#ECEFF1; color:#546E7A;" onclick="window.clearOrphanAxe()">EFFACER L'AXE ET CONTINUER</button>
            </div>
        </div>
    </div>
    </div> 
  
  <div class="app-container"> <div id="zonePatient" class="grid-item">
      

        <div id="patientSummaryContent" style="width:100%;">
            <span style="color:#B0BEC5; font-style:italic;">En attente d'identification...</span>
        </div>
        <div id="displayChrono" style="font-weight:bold; color:var(--primary-deep);">00:00</div>
    </div>

<div id="zonePilotage" class="grid-item">
        <div class="phase-badge" style="margin-bottom: 5px;"><span id="dispPhase">INIT</span></div>
        
        <div style="display:flex; gap:10px; align-items:center;">
            <button id="btnPilotOD" class="btn-pilot" onclick="window.setEye('OD')">OD</button>
            <div id="dispMode" class="btn-mode-display">MONOCULAIRE</div>
            <button id="btnPilotOG" class="btn-pilot" onclick="window.setEye('OG')">OG</button>
        </div>
    </div>

    <div id="zoneVisuels" class="grid-item">
        <div style="display:flex; gap:10px;">
            <div id="visBoxOD" class="va-box-display" data-eye="OD">--</div>
            <div id="visBoxOG" class="va-box-display" data-eye="OG">--</div>
        </div>
    </div>

<div id="examDataStrip" class="grid-item exam-data-strip hidden">
         
         <div class="data-col col-passive">
             <div class="col-title title-ra">AR</div>
             <div class="data-line"><input type="text" id="raOD_sph" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="raOD_cyl" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="raOD_axe" class="val-input" readonly></div>
         </div>

         <div class="data-col col-passive">
             <div class="col-title">LM</div>
             <div class="data-line"><input type="text" id="frontoOD_sph" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="frontoOD_cyl" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="frontoOD_axe" class="val-input" readonly></div>
         </div>

         <div id="subjDispOD" class="data-col col-active">
             <div class="col-title title-subj">&nbsp;</div>
             <div class="data-line"><span id="disp_subjOD_sph" class="val-input val-big">--</span></div>
             <div class="data-line"><span id="disp_subjOD_cyl" class="val-input val-big">--</span></div>
             <div class="data-line"><span id="disp_subjOD_axe" class="val-input val-big">--</span></div>
         </div>

         <div class="center-labels">
            <div class="col-title" style="border:none; visibility:hidden; height:20px;">&nbsp;</div>
            <div class="label-row">S</div>
            <div class="label-row">C</div>
            <div class="label-row">A</div>
         </div>
         <div id="subjDispOG" class="data-col col-active">
             <div class="col-title title-subj">&nbsp;</div>
             <div class="data-line"><span id="disp_subjOG_sph" class="val-input val-big">--</span></div>
             <div class="data-line"><span id="disp_subjOG_cyl" class="val-input val-big">--</span></div>
             <div class="data-line"><span id="disp_subjOG_axe" class="val-input val-big">--</span></div>
         </div>

         <div class="data-col col-passive">
             <div class="col-title">LM</div>
             <div class="data-line"><input type="text" id="frontoOG_sph" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="frontoOG_cyl" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="frontoOG_axe" class="val-input" readonly></div>
         </div>

         <div class="data-col col-passive">
             <div class="col-title title-ra">AR</div>
             <div class="data-line"><input type="text" id="raOG_sph" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="raOG_cyl" class="val-input" readonly></div>
             <div class="data-line"><input type="text" id="raOG_axe" class="val-input" readonly></div>
         </div>
         
         <div id="dataSection" style="display:none;"></div> 
    </div><div id="schemaContainer">
    <div id="animTargetCircle" class="anim-bubble bubble-target">Verre<br>(+0.25)</div>
    <div id="animArrowLine" class="arrow-connector"></div>
    <div id="animBaseCircle" class="anim-bubble bubble-base">Sphère<br>testée</div>
    <div id="animArrowLineMinus" class="arrow-connector-right"></div>
    <div id="animTargetCircleMinus" class="anim-bubble bubble-target-minus">Verre<br>(-0.25)</div>

   <div id="jccVisuals" class="jcc-container hidden">
    <div id="visPos1" class="jcc-visual">
        <span class="jcc-label">1</span>
        <svg class="arrow-svg" viewBox="0 0 100 100">
            <path d="M8,50 A42,42 0 1,1 92,50" fill="none" stroke="#04ABC6" stroke-width="5" stroke-linecap="round" />
            <polygon points="2,50 14,50 8,65" fill="#04ABC6" />
        </svg>
    </div>

    <div id="visPos2" class="jcc-visual">
        <span class="jcc-label">2</span>
        <svg class="arrow-svg" viewBox="0 0 100 100">
            <path d="M8,50 A42,42 0 1,1 92,50" fill="none" stroke="#04ABC6" stroke-width="5" stroke-linecap="round" />
            <polygon points="86,50 98,50 92,65" fill="#04ABC6" />
        </svg>
    </div>
</div>
      
    <div id="axisControls" class="response-area hidden" style="position: absolute; bottom: 0px; width: 100%; pointer-events: auto;">
        <div id="axisDecisions" class="decision-row hidden">
            <button class="btn-decision btn-blue" onclick="window.handleJccChoice('pos1')">Mieux 1</button>
            <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
                <button class="btn-decision btn-green" onclick="window.handleJccChoice('same')">Pareil</button>
                <button id="btnReplayAxis" class="hidden" onclick="window.runJccSequence()">Retester</button>
            </div>
            <button class="btn-decision btn-orange" onclick="window.handleJccChoice('pos2')">Mieux 2</button>
        </div>
    </div>
</div>

  <div id="zoneLettres" class="grid-item">
        <div id="waitingMsg" style="text-align:center; color:#B0BEC5;">
            <p style="font-size:1.5rem;">L'examen commencera ici.</p>
        </div>

        <div id="examContent" class="hidden" style="width:100%; display:flex; flex-direction:column; align-items:center;">
            <div id="letterBox" class="letter-display">...</div>
            <div id="systemMsg" class="message-box">En attente...</div>

            <div id="axisZone" class="response-area hidden">
                
            </div>
        </div>
    </div>

<button id="btnRandomLetters" onclick="window.forceChangeLetters()" title="Changer les lettres">
    <svg viewBox="0 0 24 24">
        <polyline points="16 3 21 3 21 8"></polyline>
        <line x1="4" y1="20" x2="21" y2="3"></line>
        <polyline points="21 16 21 21 16 21"></polyline>
        <line x1="15" y1="15" x2="21" y2="21"></line>
        <line x1="4" y1="4" x2="9" y2="9"></line>
    </svg>
</button>
  
    <div id="zoneBoutons" class="grid-item">
        <div id="standardButtons" class="response-area hidden">
            <p style="margin-bottom:10px; font-weight:600; color:var(--text-muted); margin-top:0;">Combien de lettres lues ?</p>
            <div id="btnContainer" class="btn-grid"></div>
        </div>

        <div id="cadenceButtons" class="response-area hidden">
            <p style="margin-bottom:10px; font-weight:600;">Vitesse de lecture ?</p>
            
            <div style="display:flex; justify-content:center; gap:15px;">
                <button class="btn-action btn-tortue" onclick="window.handleCadence('turtle')">
                    <span class="emoji-icon">🐢</span> Hésitant
                </button>

                <button class="btn-action btn-lapin" onclick="window.handleCadence('rabbit')">
                    <span class="emoji-icon">🐇</span> Fluide
                </button>
            </div>
        </div>
      <div id="checkPlusZone" class="response-area hidden">
    
    <div id="stepPlusWrapper">
        <button id="btnPlus025" class="btn-timer hidden" onclick="window.triggerFogCheck()">TESTER +0.25 (3s)</button>
        
        <div id="decisionsPlus" class="decision-row-round hidden">
            <button class="btn-round btn-round-green" onclick="window.decidePlus('better')">
                Préfère<br>(+0.25)
            </button>

            <button class="btn-round btn-round-outline" onclick="window.decidePlus('same')">
                Pareil
            </button>

            <div class="btn-col-group">
                <button class="btn-round btn-round-blue" onclick="window.decidePlus('worse')">
                    Sphère<br>testée
                </button>
                
                <button class="btn-round btn-round-grey" onclick="window.relaunchPlus()">
                    Retester
                </button>
            </div>
        </div>
    </div>

    <div id="stepMinusWrapper" class="hidden">
        <button id="btnMinus025" class="btn-timer hidden" onclick="window.triggerDefogCheck()">TESTER -0.25 (1.5s)</button>
        
        <div id="decisionsMinus" class="decision-row-round hidden">
            
            <div class="btn-col-group">
                <button class="btn-round btn-round-blue" onclick="window.decideMinus('worse')">
                    Sphère<br>testée
                </button>
                
                <button class="btn-round btn-round-grey" onclick="window.relaunchFullCheck()">
                    Retester
                </button>
            </div>

            <button class="btn-round btn-round-outline" onclick="window.decideMinus('same')">
                Pareil
            </button>

            <button class="btn-round btn-round-red" onclick="window.decideMinus('better')">
                Préfère<br>(-0.25)
            </button>
        </div>
    </div>

</div>

        
    <div id="schoberStep" class="hidden">
        <div style="max-width:800px; width:100%; background:white; padding:20px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.2);">
            <div class="step-instruction">
                <strong>Que voit le patient au test de Schober ?</strong><br>
                <span style="font-size:0.9rem; color:#546E7A;">Cliquez sur l'image correspondant pour déterminer le protocole.</span>
            </div>
            <div class="schober-container">
        <div class="schober-group-title">Vision Binoculaire Possible</div>

        <div class="schober-row">
            <div class="schober-sub-group">
                <div class="schober-sub-title">Vision Simultanée</div>
                <div class="schober-grid">
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(1, 'bino', 'AUTO')">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross" />
                            <circle cx="50" cy="50" r="35" class="sch-circle" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="schober-sub-group">
                <div class="schober-sub-title">Neutralisation Intermittente</div>
                <div class="schober-grid">
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(2, 'bino', 'OD')">
                         <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">OD+</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross" />
                            <circle cx="50" cy="50" r="35" class="sch-circle sch-faint" />
                        </svg>
                    </button>
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(3, 'bino', 'OG')">
                        <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">OG+</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross sch-faint" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross sch-faint" />
                            <circle cx="50" cy="50" r="35" class="sch-circle" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="schober-container" style="border-color:#FFCDD2; background:#FFEBEE;">
        <div class="schober-group-title" style="color:#D32F2F; border-color:#FFCDD2;">Pas de Vision Binoculaire</div>

        <div class="schober-row">
            <div class="schober-sub-group">
                <div class="schober-sub-title">Alternance Facile</div>
                <div class="schober-grid">
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(4, 'mono', 'OD')">
                         <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">DÉPART OD</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <path d="M20 20 L40 20 L30 10 Z" fill="#fff"/>
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross" />
                        </svg>
                    </button>
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(5, 'mono', 'OG')">
                         <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">DÉPART OG</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <path d="M60 20 L80 20 L70 10 Z" fill="#fff"/>
                            <circle cx="50" cy="50" r="35" class="sch-circle" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="schober-sub-group">
                <div class="schober-sub-title">Alternance difficile ou Neutra.</div>
                <div class="schober-grid">
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(6, 'mono', 'OD')">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross" />
                        </svg>
                    </button>
                    <button class="btn-schober" onclick="window.confirmSchoberSelection(7, 'mono', 'OG')">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="35" class="sch-circle" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="schober-sub-group">
                <div class="schober-sub-title">Monophtalme ou Amblyopie</div>
                <div class="schober-grid">
                      <button class="btn-schober" style="border-style:dashed;" onclick="window.confirmSchoberSelection(8, 'mono', 'OD')">
                         <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">MONO</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="50" y1="32.5" x2="50" y2="67.5" class="sch-cross" />
                            <line x1="32.5" y1="50" x2="67.5" y2="50" class="sch-cross" />
                        </svg>
                    </button>
                    <button class="btn-schober" style="border-style:dashed;" onclick="window.confirmSchoberSelection(9, 'mono', 'OG')">
                        <div style="position:absolute; top:2px; left:2px; color:#fff; font-size:0.6rem;">MONO</div>
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="35" class="sch-circle" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>

</div>
 
</div>

<script>
// --- STARTUP LOGIC ---
window.startAppSequence = function() {
    window.initVoices();
    window.initClock(); // Démarrage Horloge
    // Génération UID immédiate
    var uid = window.generateShortUID();
    document.getElementById('inUID').value = uid;

    // Ouverture Fenêtre 1 (Identification)
    document.getElementById('modalPatientID').classList.remove('hidden');
};

// Transition Fenêtre 1 -> Fenêtre 2
window.validatePatientID = function() {
    var dob = document.getElementById('inDob').value;
    if(!dob) { alert("La date de naissance est obligatoire."); return; }

    // Ferme Modal ID
    document.getElementById('modalPatientID').classList.add('hidden');

    // Remplissage partiel du résumé (Nom/Prénom)
    var nom = document.getElementById('inName').value || "-";
    var summaryHTML = `<div class="summary-grid"><div class="summary-row"><span class="summary-lbl">Patient</span><span class="summary-val">${nom.toUpperCase()}</span></div></div>`;
    document.getElementById('patientSummaryContent').innerHTML = summaryHTML;

    // Ouvre Modal Choix Méthode (STEP 2)
    document.getElementById('modalEntryMethod').classList.remove('hidden');
};
// --- CLOCK & CHRONO ---
window.initClock = function() {
    setInterval(function() {
        var now = new Date();
        // Date format: "Dimanche 14 Décembre"
        var options = { weekday: 'long', day: 'numeric', month: 'long' };
        var dateStr = now.toLocaleDateString('fr-FR', options);
        document.getElementById('displayDate').innerText = dateStr;

        // Time format: "14:30"
        var timeStr = now.toLocaleTimeString('fr-FR', {hour: '2-digit', minute:'2-digit'});
        document.getElementById('displayTime').innerText = timeStr;
    }, 1000);
};

var chronoInterval = null;
var startTime = null;
window.startChrono = function() {
    if(chronoInterval) return; // Déjà démarré
    startTime = Date.now();
    chronoInterval = setInterval(function() {
        var delta = Date.now() - startTime;
        var totalSeconds = Math.floor(delta / 1000);
        var m = Math.floor(totalSeconds / 60);
        var s = totalSeconds % 60;
        // Format MM:SS
        var mStr = m < 10 ? "0" + m : m;
        var sStr = s < 10 ? "0" + s : s;
        document.getElementById('displayChrono').innerText = mStr + ":" + sStr;
    }, 1000);
};

// --- GLOBALS PROMPTS ---
window.NEXT_PROMPTS = ["et ici ?", "lisez moi ces lettres là", "et celles-ci ?", "pouvez-vous lire ces lettres ci ?"];
window.getRandomPrompt = function() {
    return window.NEXT_PROMPTS[Math.floor(Math.random() * window.NEXT_PROMPTS.length)];
};

// Fonction utilitaire pour harmoniser l'affichage des acuités (ex: 1 -> 1.0)
function formatVA(val) {
    if (val === "--" || val === undefined || val === 0 || val === "") return "--";
    var n = parseFloat(val);
    if (isNaN(n)) return val;
    if (n === 1) return "1.0";
    if (n === 2) return "2.0";
    return val;
}
  
// --- FONCTIONS UTILITAIRES ---

  function showAmblyopiaSafetyModal() {
    const eye = appState.activeEye;
    const lastVA = appState.subj[eye].va;
    const isNegative = (appState.subj[eye].sphere < 0);

    // --- LOGIQUE DE REBROUILLAGE FORCÉ (+0.50) ---
    // On annule les deux échecs de -0.25
    let currentSph = parseFloat(appState.subj[eye].sphere);
    let lastValidSph = currentSph + 0.50;

    // On applique la correction immédiatement
    appState.subj[eye].sphere = lastValidSph;

    Swal.fire({
        title: 'Plateau d\'acuité détecté',
        html: `L'acuité visuelle n'augmente plus malgré deux débrouillages consécutifs.<br><br>
               <b>Diagnostic probable :</b> Amblyopie ou Limite physiologique de l'œil.<br>
               <span style="font-size:0.9rem; color:#78909C;">(Sphère au palier atteinte)</span><br><br>
               L'examen continue avec la dernière valeur stable :<br><br>
               <div style="background:#f4f4f4; padding:15px; border-radius:8px; border:1px solid #04ABC6;">
               <b style="font-size:1.3rem; color:#37474F;">Sphère : ${lastValidSph > 0 ? '+' : ''}${lastValidSph.toFixed(2)} | Acuité : ${formatVA(lastVA)}</b>
               </div>`,
        icon: 'info',
        confirmButtonText: isNegative ? 'TERMINER CET ŒIL' : 'VÉRIFIER LA SPHÈRE',
        confirmButtonColor: '#04ABC6',
        allowOutsideClick: false
    }).then((result) => {
        if (result.isConfirmed) {
            if (isNegative) {
                // MYOPE : On valide et on finit
                updateDisplay("Plateau détecté : retour au palier et fin.");
                finishSb10ForEye();
            } else {
                // HYPERMÉTROPE : On lance le test +0.25
                updateDisplay("Plateau détecté : passage aux verres vérificateurs.");

                // --- CORRECTION : ON REDESCEND SUR LA LIGNE DU PALIER ---
                setVaToIndexClosest(lastVA); // lastVA est l'acuité du palier (ex: 0.6)
                nextLetters(); // On rafraîchit les lettres à l'écran
                // -------------------------------------------------------

                initSphereCheckPlus(true); 
            }
        }
    });
}
  window.getVal = function(id) { 
    var el = document.getElementById(id);
    if(!el || !el.value) return 0;
    return parseFloat(el.value.replace(',', '.')) || 0; 
};

  // --- AJOUT : FONCTION DE NETTOYAGE VA ---
window.cleanAndSyncVA = function(lettersRead) {
    // On définit les phases où la VA ne doit pas être mise à jour
    const sensitivePhases = [
        "Vérification de Swéb", 
        "Vérification de Swéb_AVEC_VERRE", 
        "Vérification de Swéb_CUMUL_FINAL",
        "SphereCheckMinus",
        "SphereCheckPlus",
        "QuartConcaveMyope",
        "AxisCheck"
    ];

    // Sécurité : si on est dans un test spécial, on ne touche pas à la VA confirmée
    if (sensitivePhases.includes(appState.examPhase) || appState.isCheckingGain || appState.safety_mode) {
        return;
    }

    const currentVA = ACUITY_TABLE[appState.vaIndex].va;

    // Règle médicale : on valide le palier seulement si score >= 3
    if (lettersRead >= 3) {
        appState.subj[appState.activeEye].va = currentVA;
    }
};
window.setHTML = function(id, val) { 
    var el = document.getElementById(id); if(el) el.innerHTML = val;
};
window.generateShortUID = function() {
    const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let part1 = "", part2 = "";
    for(let i=0; i<3; i++) part1 += chars.charAt(Math.floor(Math.random() * chars.length));
    for(let i=0; i<3; i++) part2 += chars.charAt(Math.floor(Math.random() * chars.length));
    return part1 + "-" + part2;
};

// --- VALIDATION SAISIE NUMERIQUE & FORMATAGE ---
window.validateNumberInput = function(el) {
    el.value = el.value.replace(/[^0-9.,-]/g, '');
};

// --- MODALE WARNING ---
window.closeWarningModal = function() {
    document.getElementById('modalWarning').classList.add('hidden');
    if(appState.lastInvalidInputId) {
        var el = document.getElementById(appState.lastInvalidInputId);
        if(el) {
            el.value = ""; // Vide le champ en erreur
            el.focus();    // Redonne le focus
        }
        appState.lastInvalidInputId = null;
    }
};

window.checkSphere = function(el) {
    if(!el.value) return;
    var val = parseFloat(el.value.replace(',', '.'));
    if(isNaN(val)) return;

    // CHECK LIMITES AVANT CORRECTION
    if (val < -29.00 || val > 26.75) {
        appState.lastInvalidInputId = el.id;
        document.getElementById('modalWarning').classList.remove('hidden');
        return;
    }

    val = Math.round(val * 4) / 4; // Step 0.25
    el.value = val.toFixed(2);
};
// --- DEBUT LOGIQUE TRANSPOSITION (CORRIGÉ) ---
var tempCylInputId = null; 

window.checkCylInput = function(el) {
    if(!el.value) return;
    var val = parseFloat(el.value.replace(',', '.'));
    if(isNaN(val)) return;

    // DETECTION CYLINDRE POSITIF
    if(val > 0) {
        tempCylInputId = el.id; 
        document.getElementById('txtPosCylVal').innerText = "+" + val.toFixed(2);
        document.getElementById('modalCylTranspose').classList.remove('hidden');
        el.blur(); 
        return;
    }

    if (val < -10.00) {
        appState.lastInvalidInputId = el.id;
        document.getElementById('modalWarning').classList.remove('hidden');
        return;
    }

    val = Math.round(val * 4) / 4; 
    el.value = (val > 0 ? "+" : "") + val.toFixed(2);
};
// --- LOGIQUE TRANSPOSITION & AXE ---

// 1. Déclenchement de la transposition (Ouvre la modale ou calcule direct)
window.applyTransposition = function() {
    if(!tempCylInputId) return;

    // Récupération des éléments
    var parts = tempCylInputId.split('_'); 
    var prefix = (parts.length === 3) ? parts[0] + "_" + parts[1] : parts[0];
    var elAxe = document.getElementById(prefix + '_axe');

    // Vérification si l'axe est déjà rempli
    var axeVal = elAxe.value;
    var axe = (axeVal && axeVal !== "") ? parseFloat(axeVal) : 0;

    // CAS 1 : L'axe est vide ou 0 -> On ouvre la modale de demande
    if (axe === 0) {
        // On vide le champ de la modale pour une nouvelle saisie
        document.getElementById('inputTranspAxis').value = ""; 
        // On ouvre la modale
        document.getElementById('modalAskAxis').classList.remove('hidden');
        // On met le focus dans le champ (meilleure UX)
        setTimeout(function() { document.getElementById('inputTranspAxis').focus(); }, 100);
        return; 
    }

    // CAS 2 : L'axe est déjà là -> On lance le calcul directement
    performTranspositionMath(axe);
};

// 2. Validation depuis la modale "Demande Axe" (Bouton VALIDER)
window.validateTranspositionAxis = function() {
    var input = document.getElementById('inputTranspAxis');
    var val = parseFloat(input.value);

    if (isNaN(val) || val < 0 || val > 180) {
        alert("Merci d'entrer un axe valide entre 0 et 180.");
        return;
    }

    // On ferme la modale d'axe
    document.getElementById('modalAskAxis').classList.add('hidden');

    // On lance le calcul avec la valeur saisie
    performTranspositionMath(val);
};

// 3. Fonction technique commune (Le calcul mathématique)
function performTranspositionMath(axeInitial) {
    var parts = tempCylInputId.split('_'); 
    var prefix = (parts.length === 3) ? parts[0] + "_" + parts[1] : parts[0];

    var elCyl = document.getElementById(tempCylInputId);
    var elSph = document.getElementById(prefix + '_sph');
    var elAxe = document.getElementById(prefix + '_axe');

    var cyl = parseFloat(elCyl.value.replace(',', '.'));
    var sph = elSph.value ? parseFloat(elSph.value.replace(',', '.')) : 0;

    // CALCUL
    var newSph = sph + cyl;
    var newCyl = -cyl;
    var newAxe = (axeInitial + 90) % 180;
    if (newAxe >= 180) newAxe = 0;

    // APPLICATION (avec gestion du signe + pour la nouvelle sphère)
    let finalSph = Math.round(newSph * 4) / 4;
    let finalCyl = Math.round(newCyl * 4) / 4;

    elSph.value = (finalSph > 0 ? "+" : "") + finalSph.toFixed(2);
    elCyl.value = (finalCyl > 0 ? "+" : "") + finalCyl.toFixed(2); // Sécurité même si le but est d'être négatif
    elAxe.value = Math.round(newAxe);

    // FERMETURE GENERALE
    window.closeTransposeModal(); // Ferme la modale orange principale
    if(window.onRaChanged) window.onRaChanged();
}

// 4. Fermeture simple de la modale d'axe (Annuler)
window.closeAskAxisModal = function() {
    document.getElementById('modalAskAxis').classList.add('hidden');
};
window.invertCylSign = function() {
    if(!tempCylInputId) return;
    var el = document.getElementById(tempCylInputId);
    var val = parseFloat(el.value.replace(',', '.'));

    // APPLICATION DE L'INVERSION
    el.value = (-val).toFixed(2); // La valeur est mise ici

    // On ferme juste la modale sans vider le champ
    window.closeTransposeModal();

    if(window.onRaChanged) window.onRaChanged();
};

// Fonction pour le bouton "Annuler / Corriger manuellement"
window.cancelCorrection = function() {
    var el = document.getElementById(tempCylInputId);
    if(el) { 
        el.value = ""; // C'EST ICI SEULEMENT QU'ON VIDE LE CHAMP
        el.focus(); 
    }
    window.closeTransposeModal();
};

window.closeTransposeModal = function() {
    document.getElementById('modalCylTranspose').classList.add('hidden');
    tempCylInputId = null;
};
// --- FIN LOGIQUE TRANSPOSITION ---
window.forceNegativeCyl = function(el) {
    if(!el.value) return;
    var val = parseFloat(el.value.replace(',', '.'));
    if(isNaN(val)) return;

    // Auto-conversion positif -> négatif (Logique Opto Standard)
    if(val > 0) val = -val;

    // CHECK LIMITES (-10.00 à 0)
    if (val < -10.00 || val > 0) {
        appState.lastInvalidInputId = el.id;
        document.getElementById('modalWarning').classList.remove('hidden');
        return;
    }

    val = Math.round(val * 4) / 4; // Step 0.25
    // Ajoute le "+" si positif, sinon laisse tel quel
    el.value = (val > 0 ? "+" : "") + val.toFixed(2);
};

// Fonction normalisation axe (0-175 avec modulo 180)
function normalizeAxis(val) {
    // Arrondi au pas de 5
    val = Math.round(val / 5) * 5;
    // Modulo 180 qui gère les négatifs (ex: -5 => 175)
    val = (val % 180 + 180) % 180;
    
    // --- RÈGLE CLINIQUE : 180° devient 0° ---
    if (val === 180 || val === 0) return 0;
    
    return val;
}

window.checkAxis = function(el) {
    if(!el.value) return;
    var val = parseFloat(el.value);
    if(isNaN(val)) return;

    // NOUVELLE VALIDATION: Limites strictes pour éviter les fautes de frappe (ex: 1400)
    if (val < 0 || val > 180) {
        appState.lastInvalidInputId = el.id;
        document.getElementById('modalWarning').classList.remove('hidden');
        return;
    }

    val = normalizeAxis(val);
    el.value = val;
};

// --- LOGIQUE CHECKBOX ---
window.toggleMyopiaHyper = function(source) {
    var chkMyopia = document.getElementById('chkMyopia');
    var chkHyper = document.getElementById('chkHyper');
    if(source === 'myopia' && chkMyopia.checked) {
        chkHyper.checked = false;
    } else if(source === 'hyper' && chkHyper.checked) {
        chkMyopia.checked = false;
    }
};

// --- TTS & LOCK ---
window.initVoices = function() {
    window.checkMyopia();
    window.speechSynthesis.getVoices();
}

  function say(textOrArray, callback, keepLocked) {
    if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();

    // Verrouillage immédiat dès qu'on commence à parler
    appState.isSpeaking = true;
    updateLockUI(true);

    var text = Array.isArray(textOrArray) ? textOrArray[Math.floor(Math.random() * textOrArray.length)] : textOrArray;
    var u = new SpeechSynthesisUtterance(text);
    u.lang = 'fr-FR'; u.rate = 1.0; 
    
    var voices = window.speechSynthesis.getVoices();
    var bestVoice = voices.find(v => v.lang.includes('fr') && (v.name.includes('Google') || v.name.includes('Thomas')));
    if (!bestVoice) bestVoice = voices.find(v => v.lang.includes('fr'));
    if (bestVoice) u.voice = bestVoice;

    u.onend = function() {
        // --- LOGIQUE ANTI-CLIGNOTEMENT ---
        if (keepLocked) {
            // On force le maintien du verrouillage pour la phrase suivante
            appState.isSpeaking = true;
            updateLockUI(true);
        } else {
            appState.isSpeaking = false;
            updateLockUI(false);
        }
        if (callback) callback();
    };
    
    u.onerror = function() {
        appState.isSpeaking = false;
        updateLockUI(false);
    };

    window.speechSynthesis.speak(u);
}
function updateLockUI(locked) {
    var btns = document.querySelectorAll('.btn-resp, .btn-action, .btn-timer, .btn-decision');
    btns.forEach(function(b) {
        if(locked) {
            b.classList.add('locked');
            b.style.pointerEvents = 'none'; // Sécurité JS supplémentaire
        } else {
            b.classList.remove('locked');
            b.style.pointerEvents = 'auto';
        }
    });
}

// --- LOGIQUE AGE ---
function getAgeFromDob(dobString) {
    var today = new Date(); var birthDate = new Date(dobString);
    var age = today.getFullYear() - birthDate.getFullYear();
    var m = today.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) age--;
    return age;
}
function getAgeScore(age) {
    if (age <= 10) return 6; if (age <= 20) return 5; 
    if (age <= 30) return 4; if (age <= 50) return 2; 
    if (age <= 70) return 1; return 0; 
}
window.checkMyopia = function() {
    var s1 = window.getVal('raOD_sph'); 
    var s2 = window.getVal('raOG_sph');
    var btn = document.getElementById('btnProfile1');
    
    if (btn) { 
        if (s1 < 0 || s2 < 0) { 
            // Myopie détectée : On cache le bouton mais ON GARDE SA PLACE
            btn.style.visibility = 'hidden'; 
        } else { 
            // Sinon : On le rend visible
            btn.style.visibility = 'visible'; 
        } 
    }
};
// --- DATA ---
var ACUITY_TABLE = [
    { va: 0.04, lines: ["U", "P", "F", "V"] },
    { va: 0.05, lines: ["E", "Z", "N", "R"] },
    { va: 0.06, lines: ["H", "U", "D", "V"] },
    { va: 0.08, lines: ["N Z", "P U", "V H"] },
    { va: 0.10, lines: ["D U F", "P H N"] },
    { va: 0.12, lines: ["E N R", "R H P"] },
    { va: 0.16, lines: ["U P H", "V R F"] },
    { va: 0.20, lines: ["N Z V", "P R H"] },
    { va: 0.25, lines: ["H D F", "U R Z"] },
    { va: 0.32, lines: ["D F U N R", "R U P E H"] },
    { va: 0.40, lines: ["Z V D F H", "U V N R Z"] },
    { va: 0.50, lines: ["U R N P E", "R U P E H"] },
    { va: 0.60, lines: ["V N R U F", "R H U E P"] },
    { va: 0.80, lines: ["F D U R N", "P R H U E"] },
    { va: 1.00, lines: ["H P Z E V", "H D E P N"] },
    { va: 1.25, lines: ["H E P U R", "E P N R U"] },
    { va: 1.60, lines: ["Z R N V U", "U R N P E"] },
    { va: 2.00, lines: ["V H F D Z", "R N U F D"] }
];

var appState = {
    isRunning: false, activeEye: 'OD', firstEye: 'OD', profile: null, initProfile: null, 
    baseProfile: null, 
    isSpeaking: false, // Variable de lock

  // --- AJOUTEZ LA LIGNE ICI ---
    axisIntroDone: false,

  // --- AJOUTEZ CES DEUX LIGNES ICI ---
    lettersBeforeAxis: 0, // Score de référence avant le test de l'axe
    axisInitialRA: 0,     // Valeur de l'axe au départ (RA) pour reset si besoin
    // ----------------------------------
  
    subj: { 
    OD: { sphere: 0, cyl: 0, axe: 0, va: "--", swebDone: false }, 
    OG: { sphere: 0, cyl: 0, axe: 0, va: "--", swebDone: false } 
},
  fogTotalAdded: 0,  // <--- LIGNE À AJOUTER
    retestCount: 0,    // <--- LIGNE À AJOUTER (pour la sécurité Retester)
    memCyl: { OD: null, OG: null }, 
    vaIndex: 0, startVaIndex: 0, letterIndex: 0, pendingLetters: null, defoggedInZone: false,
    examPhase: "Sb0.2", patientInfo: { name: "", forename: "", dob: "", age: 0, uid: "" },
    sb02_OD_ok: false, sb02_OG_ok: false, seen025_OD: false, seen025_OG: false,
    sb05_OD_ok: false, sb05_OG_ok: false, sb10_OD_ok: false, sb10_OG_ok: false,
    tqs_attempted_06: false, count06_validations: 0, tqsFogCount: 0, checkStep: null, tempScore: 0, baseSphereValue: 0,

    // --- NOUVEAUX ÉTATS DE SÉCURITÉ ---
    sb10_line_defog: 0, 
    safety_mode: false,
    safety_mem_letters: 0,
    hasRestartedSb10: false, // Flag anti-boucle
    
    // --- ÉTATS POUR LE TEST DE GAIN (QUART CONCAVE) ---
    scoreN_SansVerre: 0,        // Score initial sur ligne N (ex: 10/10)
    scoreNPlus1_SansVerre: 0,   // Score sur ligne N+1 sans le -0.25
    scoreNPlus1_AvecVerre: 0,   // Score sur ligne N+1 avec le -0.25
    isCheckingGain: false,      // Flag d'activation du test de gain
    
    // ----------------------------------
    handednessEye: 'OD', // Valeur par défaut
    pendingSchober: null, // Stockage temporaire du choix Schober

    saved_sb05: { OD: 0, OG: 0 }, saved_sb10: { OD: 0, OG: 0 },
    axisStep: 20, axisDirectionHistory: [],
  // --- NOUVELLES LIGNES DE SÉCURITÉ À AJOUTER ICI ---
    axisRepeatCount: 0,
    axisHelpMode: false,
    // --------------------------------------------------
  cylHigh: false,
  
    lastInvalidInputId: null 
};

// --- LOGIQUE WORKFLOW ---

// 1. CALCUL PROFIL
window.calculateProfileAndShowData = function() {
    var age = getAgeFromDob(document.getElementById('inDob').value);
    var score = getAgeScore(age);
    score += parseInt(document.getElementById('inRhythm').value);
    score += parseInt(document.getElementById('inSigns').value);
    if(document.getElementById('chkMyopia').checked) score += 1;
    if(document.getElementById('chkHyper').checked) score += 1;
    if(document.getElementById('chkNear').checked) score += 1;
    if(document.getElementById('chkNoSpecs').checked) score += 1;
    if(document.getElementById('chkMono').checked) score += 1;

    var p = (score <= 5) ? "1" : (score <= 8) ? "2" : (score <= 12) ? "3" : "3+";

    // Affiche la section Données (Gauche) et lance l'INSTALLATION (STEP 6)
    revealDataSection(p, false); 
};
window.forceProfileAndShowData = function(forcedProfile) {
    appState.baseProfile = forcedProfile;
    var finalProfile = forcedProfile;
    if (forcedProfile === '1') {
        var s1 = window.getVal('raOD_sph');
        var s2 = window.getVal('raOG_sph');
        if (s1 < 0 || s2 < 0) { finalProfile = '2'; }
    }
    revealDataSection(finalProfile, false);
};

function revealDataSection(profile, inputsEnabled) {
    appState.initProfile = profile; 
    setHTML('displayProfileName', profile);

    // Fermeture Fenêtre Profil
    document.getElementById('modalProfileCalc').classList.add('hidden');

    // --- CORRECTION : AFFICHAGE LIGNE UNIQUE (SANS UID) ---
    // --- BLOC MODIFIÉ : Affichage final avec Age ---
    var nom = document.getElementById('inName').value || "-";
    var prenom = document.getElementById('inForename').value || "";
    var pColor = getProfileColor(profile);
    
    // Calcul de l'âge
    var dob = document.getElementById('inDob').value;
    var ageStr = dob ? getAgeFromDob(dob) + " ans" : "";

    var summaryHTML = `
        <div class="patient-info-block">
            <span style="color:var(--primary);">${nom}</span> 
            <span style="color:var(--primary);">${prenom}</span>
            
            <span style="font-size:1.1rem; color:#90A4AE; font-weight:600; text-transform:none;">${ageStr}</span>
        </div>
        
        <div class="pat-profile-badge" style="background:${pColor}">${profile}</div>
    `;
    document.getElementById('patientSummaryContent').innerHTML = summaryHTML;
    // -------------------------------------------------------------

    document.getElementById('dataSection').classList.remove('hidden');
    toggleInputs('dataSection', inputsEnabled);

    // Passage à l'installation
    window.openPositioningModal();
}

function getProfileColor(p) {
    if(p==='1') return '#26A69A'; if(p==='2') return '#42A5F5'; if(p==='3') return '#FFA726'; return '#EF5350';
}

// 2. MODES SAISIE ET IMPORT (GESTION DE LA NOUVELLE MODALE DE CHOIX)

// Fonction appelée par les boutons de la modale "Importation des données"
// --- GESTION DES MODALES SEPAREES (RA & FRONTO) ---

// 1. Simulation d'import (Version 2.0)
window.simulateImport = function() {
    // On remplit directement les champs cachés du dashboard
    document.getElementById('raOD_sph').value = "-1.50";
    document.getElementById('raOD_cyl').value = "-0.50";
    document.getElementById('raOD_axe').value = "180";
    document.getElementById('raOG_sph').value = "-1.75";
    document.getElementById('raOG_cyl').value = "-0.25";
    document.getElementById('raOG_axe').value = "170";

    alert("Données simulées importées !");
    // On lance le calcul de profil si besoin
    if(window.onRaChanged) window.onRaChanged();
};

// 2. Ouvrir une modale spécifique
window.openModal = function(type) {
    // On charge les données actuelles dans la modale pour ne rien perdre
    syncDashboardToModal(type);

    document.getElementById('modalEntryMethod').classList.add('hidden'); // Cache le menu
    document.getElementById('modalInput' + type).classList.remove('hidden'); // Affiche la modale (AutoRef ou Fronto)
};

// 3. Valider et fermer une modale
window.saveAndCloseModal = function(type) {
    // On sauvegarde les données vers le dashboard
    syncModalToDashboard(type);

    // Si c'est RA, on met à jour le profil myopie immédiatement
    if (type === 'AutoRef' && window.onRaChanged) window.onRaChanged();

    document.getElementById('modalInput' + type).classList.add('hidden'); // Cache modale
    document.getElementById('modalEntryMethod').classList.remove('hidden'); // Retour menu
};

// 4. Terminer la saisie (Bouton Final de la modale de choix)
var currentOrphanPrefix = ""; // Stocke l'œil qui pose problème

window.finishDataEntry = function() {
    var prefixes = ['raOD', 'raOG', 'frontoOD', 'frontoOG'];
    var errorFound = false;

    // --- 1. DÉTECTION D'INCOHÉRENCE (OUVERTURE MODALE) ---
    for (var i = 0; i < prefixes.length; i++) {
        var p = prefixes[i];
        var cylVal = parseFloat(document.getElementById(p + '_cyl').value.replace(',', '.')) || 0;
        var axeVal = document.getElementById(p + '_axe').value.trim();

        if (cylVal === 0 && axeVal !== "" && axeVal !== "0") {
            currentOrphanPrefix = p;
            document.getElementById('txtOrphanAxe').innerText = axeVal;
            document.getElementById('txtOrphanEye').innerText = p.includes('OD') ? "DROIT" : "GAUCHE";
            document.getElementById('modalAxeSecurity').classList.remove('hidden');
            errorFound = true;
            break; 
        }
    }

    if (errorFound) return; // Stoppe la fermeture si erreur

    // --- 2. REMPLISSAGE DES VIDES ET FORMATAGE ---
    var fields = ['raOD_sph', 'raOD_cyl', 'raOD_axe', 'raOG_sph', 'raOG_cyl', 'raOG_axe',
                  'frontoOD_sph', 'frontoOD_cyl', 'frontoOD_axe', 'frontoOG_sph', 'frontoOG_cyl', 'frontoOG_axe'];

    fields.forEach(function(id) {
        var el = document.getElementById(id);
        if (!el) return;
        var prefix = id.split('_')[0]; 
        var val = el.value.trim();

        if (id.includes('_cyl')) {
            if (val === "" || parseFloat(val.replace(',', '.')) === 0) {
                el.value = "0.00";
                var axeEl = document.getElementById(prefix + '_axe');
                if (axeEl) axeEl.value = "0";
            } else {
                let v = parseFloat(val.replace(',', '.'));
                el.value = (v > 0 ? "+" : "") + v.toFixed(2);
            }
        } else if (id.includes('_sph')) {
            if (val === "") el.value = "0.00";
            else {
                let v = parseFloat(val.replace(',', '.'));
                el.value = (v > 0 ? "+" : "") + v.toFixed(2);
            }
        } else if (id.includes('_axe')) {
            var cylEl = document.getElementById(prefix + '_cyl');
            var currentCyl = cylEl ? (parseFloat(cylEl.value.replace(',', '.')) || 0) : 0;
            var currentAxe = parseInt(el.value) || 0;

            // RÈGLE : Force à 0 si : pas de cylindre OU champ vide OU axe à 180
            if (currentCyl === 0 || el.value.trim() === "" || currentAxe >= 180) {
                el.value = "0";
            }
        }
    });

    // --- 3. FERMETURE ET UI ---
    document.getElementById('modalEntryMethod').classList.add('hidden');
    var nom = document.getElementById('inName').value || "-";
    var prenom = document.getElementById('inForename').value || "";
    var dob = document.getElementById('inDob').value;
    var ageStr = dob ? getAgeFromDob(dob) + " ans" : "";

    document.getElementById('patientSummaryContent').innerHTML = `
        <div class="patient-info-block">
            <span style="color:var(--primary);">${nom}</span> 
            <span style="color:var(--primary);">${prenom}</span>
            <span style="font-size:1.1rem; color:#90A4AE; font-weight:600; text-transform:none;">${ageStr}</span>
        </div>
        <div id="badgeProfilePlace"></div>`;
    
    if(appState.initProfile) updateProfileBadge(appState.initProfile);
    document.getElementById('examDataStrip').classList.add('hidden');
    document.getElementById('modalHandedness').classList.remove('hidden');
};

// Fonctions de redirection de la modale de sécurité
window.backToCylEntry = function() {
    document.getElementById('modalAxeSecurity').classList.add('hidden');
    var type = currentOrphanPrefix.startsWith('ra') ? 'AutoRef' : 'Fronto';
    window.openModal(type);
};

window.clearOrphanAxe = function() {
    document.getElementById(currentOrphanPrefix + '_axe').value = "0";
    document.getElementById('modalAxeSecurity').classList.add('hidden');
    window.finishDataEntry(); // Relance la validation
};  
  // Fonction utilitaire pour le badge couleur (A AJOUTER JUSTE APRES)
// Fonction utilitaire pour le badge (Juste le chiffre rond)
window.updateProfileBadge = function(p) {
    var color = getProfileColor(p);
    // On n'écrit plus "PROFIL", juste "p" (le chiffre)
    var html = `<div class="pat-profile-badge" style="background:${color}">${p}</div>`;
    
    var el = document.getElementById('badgeProfilePlace');
    if(el) el.innerHTML = html;
};
// UTILITAIRES DE SYNCHRO (MODALE <-> DASHBOARD)
function syncDashboardToModal(type) {
    var prefix = (type === 'AutoRef') ? 'ra' : 'fronto';
    ['OD', 'OG'].forEach(eye => {
        ['sph', 'cyl', 'axe'].forEach(field => {
            // Prend la valeur du dashboard
            var val = document.getElementById(prefix + eye + '_' + field).value;
            // La met dans la modale (si l'élément existe)
            var modEl = document.getElementById('mod_' + prefix + eye + '_' + field);
            if(modEl) modEl.value = val;
        });
    });
}

function syncModalToDashboard(type) {
    var prefix = (type === 'AutoRef') ? 'ra' : 'fronto';
    ['OD', 'OG'].forEach(eye => {
        ['sph', 'cyl', 'axe'].forEach(field => {
            // Prend la valeur de la modale
            var modVal = document.getElementById('mod_' + prefix + eye + '_' + field).value;
            // La met dans le dashboard
            var dashEl = document.getElementById(prefix + eye + '_' + field);
            if(dashEl) dashEl.value = modVal;
        });
    });
}

  // --- BLOC REPARE (A coller entre syncModalToDashboard et toggleInputs) ---

window.setHandedness = function(handEye) {
    // 1. Stockage & UI
    appState.handednessEye = handEye; 
    document.getElementById('modalHandedness').classList.add('hidden');
    document.getElementById('waitingMsg').classList.add('hidden'); 
    document.getElementById('schoberStep').classList.remove('hidden');

    // 2. Verrouillage VISUEL des boutons Schober
    var schoberBtns = document.querySelectorAll('.btn-schober');
    schoberBtns.forEach(function(btn) {
        btn.style.pointerEvents = 'none'; 
        btn.style.opacity = '0.4';        
        btn.style.filter = 'grayscale(100%)'; 
        btn.style.transition = 'all 0.3s';
    });

    // 3. Vocal + Ouverture Modale
    say("Sur l'écran en face de vous, voyez-vous une croix et un cercle, en même temps ?", function() {
        document.getElementById('modalSchoberQuestion').classList.remove('hidden');
    });
};

window.handleSchoberAnswer = function(reponse) {
    // 1. Fermer la modale
    document.getElementById('modalSchoberQuestion').classList.add('hidden');

    // Fonction déverrouillage
    var unlockButtons = function() {
        var schoberBtns = document.querySelectorAll('.btn-schober');
        schoberBtns.forEach(function(btn) {
            btn.style.pointerEvents = 'auto'; 
            btn.style.opacity = '1';          
            btn.style.filter = 'none';        
            btn.style.cursor = 'pointer';     
        });
    };

    if (reponse === 'oui') {
        unlockButtons();
    } else {
        var phraseNon = "Alors, que voyez-vous exactement ? La croix seule ? Le cercle seul ? Tantôt la croix, tantôt le cercle ? Dites moi.";
        say(phraseNon, function() {
            unlockButtons();
        });
    }
};

// --- FIN BLOC REPARE ---
  
function toggleInputs(sectionId, enable) {
    var sec = document.getElementById(sectionId);
    if(sec) {
        var inputs = sec.querySelectorAll('input:not([readonly]), select');
        inputs.forEach(function(el) { el.disabled = !enable; });
    }
}

// MISE A JOUR DYNAMIQUE DU PROFIL (Reversible)
// Variable globale pour le mode
appState.isMonocularExam = false; 

// --- Dictionnaire des phrases Schober ---
const SCHOBER_PHRASES = {
    1: "Le patient voit la croix et le cercle, en même temps (Vision simultanée).",
    2: "Le patient voit la croix en permanence, mais le cercle s'efface par intermittence (Neutralisation intermittente).",
    3: "Le patient voit le cercle en permanence, mais la croix s'efface par intermittence (Neutralisation intermittente).",
    4: "Le patient ne voit d'emblée que la croix, mais il peut facilement passer de la croix au cercle et inversement (Neutralisation alternante).",
    5: "Le patient ne voit d'emblée que le cercle, mais il peut facilement passer du cercle à la croix et inversement (Neutralisation alternante).",
    6: "Le patient ne voit que la croix, mais s'il ferme l'oeil droit, il voit le cercle (Neutralisation gauche).",
    7: "Le patient ne voit que le cercle, mais s'il ferme l'oeil gauche, il voit la croix (Neutralisation droite).",
    8: "Le patient ne voit que la croix, et s'il ferme l'oeil droit il ne voit plus rien (Monophtalme oeil droit ou amblyopie gauche profonde).",
    9: "Le patient ne voit que le cercle, et s'il ferme l'oeil gauche, il ne voit plus rien (Monophtalme oeil gauche ou amblyopie droite profonde)."
};

// 1. Fonction appelée par le clic bouton (Ouvre Modale)
window.confirmSchoberSelection = function(id, mode, eye) {
    // Stockage temporaire
    appState.pendingSchober = { mode: mode, eye: eye };

    // Injection du texte
    var text = SCHOBER_PHRASES[id] || "Confirmation du choix...";
    document.getElementById('schoberConfirmText').innerText = text;

    // Affichage Modale
    document.getElementById('modalSchoberConfirm').classList.remove('hidden');
};

// 2. Fonction Annuler (Ferme Modale, reste sur Schober)
window.cancelSchober = function() {
    appState.pendingSchober = null;
    document.getElementById('modalSchoberConfirm').classList.add('hidden');
};

// 3. Fonction Valider (Ferme Modale, lance la suite)
window.validateSchober = function() {
    document.getElementById('modalSchoberConfirm').classList.add('hidden');
    var p = appState.pendingSchober;
    if(p) {
        window.handleSchoberChoice(p.mode, p.eye);
    }
};

// --- LOGIQUE CHOIX OEIL DEPART (MODIFIE POUR 1-a) ---
window.handleSchoberChoice = function(mode, eye) {
    var startingEye = 'OD'; // Valeur par défaut de sécurité

    // CAS 1 : Vision Simultanée (Bouton 1 - Paramètre 'AUTO')
    if (eye === 'AUTO') {
        // On respecte la latéralité choisie à l'étape précédente
        if (appState.handednessEye === 'OG') {
            startingEye = 'OG';
        } else {
            startingEye = 'OD'; // Droitier ou par défaut
        }
    } 
    // CAS 2 : Problème Binoculaire (Boutons 2 à 9)
    else {
        // On impose l'œil défini par le bouton (l'œil fixateur/sain)
        startingEye = eye;
    }

    // Mise à jour de l'état global
    appState.firstEye = startingEye; 
    appState.activeEye = startingEye; // IMPORTANT : C'est cet œil qui commencera l'examen
    appState.isMonocularExam = (mode === 'mono');

    console.log("Schober Validé. Oeil de départ : " + startingEye);

    // Suite du flux -> Cache Schober, Affiche Profil
    document.getElementById('schoberStep').classList.add('hidden');
    document.getElementById('modalProfileCalc').classList.remove('hidden');
};
window.onRaChanged = function() { 
    window.checkMyopia();
    if (appState.baseProfile === "1") {
        var s1 = window.getVal('raOD_sph');
        var s2 = window.getVal('raOG_sph');
        if (s1 < 0 || s2 < 0) { appState.initProfile = "2"; setHTML('displayProfileName', "2"); } 
        else { appState.initProfile = "1"; setHTML('displayProfileName', "1"); }

        window.updateProfileBadge(appState.initProfile);
    }
};

// 3. INSTALLATION & REGLES
window.openPositioningModal = function() {
    toggleInputs('dataSection', false);
    // CORRECTION : PLUS DE MANIPULATION DE btnPosition QUI N'EXISTE PLUS
    // document.getElementById('btnPosition').classList.add('hidden'); 
    document.getElementById('modalPosition').classList.remove('hidden');
};

window.startRulesAndIntro = function() {
    // 1. Fermeture modale / Ouverture écran principal
    document.getElementById('modalPosition').classList.add('hidden');
    document.getElementById('examDataStrip').classList.remove('hidden');
    document.getElementById('waitingMsg').classList.add('hidden');
    document.getElementById('examContent').classList.remove('hidden');

    // 2. Récupération des valeurs RA
    var raOD = { s: getVal('raOD_sph'), c: getVal('raOD_cyl'), a: getVal('raOD_axe') };
    var raOG = { s: getVal('raOG_sph'), c: getVal('raOG_cyl'), a: getVal('raOG_axe') };

    // 3. Injection des valeurs RA dans les cartes Subjectif (avec gestion du signe +)
    setHTML('disp_subjOD_sph', (raOD.s > 0 ? "+" : "") + raOD.s.toFixed(2)); 
    setHTML('disp_subjOG_sph', (raOG.s > 0 ? "+" : "") + raOG.s.toFixed(2));
    
    setHTML('disp_subjOD_cyl', raOD.c.toFixed(2)); 
    setHTML('disp_subjOG_cyl', raOG.c.toFixed(2));
    
    setHTML('disp_subjOD_axe', normalizeAxis(raOD.a) + "°"); 
    setHTML('disp_subjOG_axe', normalizeAxis(raOG.a) + "°");
    
    setHTML('disp_subjOD_va', "--"); 
    setHTML('disp_subjOG_va', "--");

    // 4. FORÇAGE VISUEL (YEUX OUVERTS)
    // On met les deux cartes en Cyan (Sélectionnées)
    document.getElementById('subjDispOD').classList.add('highlight');
    document.getElementById('subjDispOG').classList.add('highlight');

    // On active les deux boutons OD/OG en haut
    var btnOD = document.getElementById('btnPilotOD');
    var btnOG = document.getElementById('btnPilotOG');
    if(btnOD) { btnOD.classList.add('active'); btnOD.classList.remove('closed'); }
    if(btnOG) { btnOG.classList.add('active'); btnOG.classList.remove('closed'); }

    // 5. TEXTES INDICATEURS
    setHTML('dispPhase', "Règles de lecture");
    
    // --- AJOUT ICI : ON FORCE L'AFFICHAGE BINOCULAIRE ---
    setHTML('dispMode', "BINOCULAIRE");
    // ----------------------------------------------------

    // LA SUITE (VOIX)
    var introText = "Pour avoir une bonne mesure de votre vision de loin, il faut lire d’une manière naturelle, c’est à dire rapide et spontanée. Si vous ne pouvez pas lire vous le dites tout de suite, et si vous faites une erreur, comme vous avez lu naturellement, elle sera plus facile à corriger ! Mais si vous lisez d’une manière lente et réfléchie, le risque est de masquer vos erreurs et on ne peut pas améliorer quelqu'un qui ne veut pas se tromper ! Donc il faut lire vite, si vous ne pouvez pas vous le dites tout de suite et si vous vous trompez aucune importance !";

    say(introText, function() {
        document.getElementById('modalIntroConfirmation').classList.remove('hidden');
    });
};
window.confirmAndLaunch = function() {
    document.getElementById('modalIntroConfirmation').classList.add('hidden');
    window.startChrono(); // DEMARRAGE CHRONO ICI
    window.triggerFinalStart();
};

window.triggerFinalStart = function() {
    // PRE-CALCUL DEBROUILLAGE Sb0.5 (Pour que le 2eme oeil soit pret)
    var raOD_sph = getVal('raOD_sph');
    var raOG_sph = getVal('raOG_sph');

    // On calcule le delta potentiel dès maintenant (pour l'utiliser plus tard)
    appState.deltaSb05_OD = (raOD_sph < 0) ? -0.75 : -0.50;
    appState.deltaSb05_OG = (raOG_sph < 0) ? -0.75 : -0.50;

    window.launchExamSequence();
};

// 4. LANCEMENT TECHNIQUE
window.launchExamSequence = function() {
    try {
        var raOD = { s: getVal('raOD_sph'), c: getVal('raOD_cyl'), a: getVal('raOD_axe') };
        var raOG = { s: getVal('raOG_sph'), c: getVal('raOG_cyl'), a: getVal('raOG_axe') };

        raOD.a = normalizeAxis(raOD.a);
        raOG.a = normalizeAxis(raOG.a);

        var p = appState.initProfile;
        if (p === '1' && (raOD.s < 0 || raOG.s < 0)) { p = '2'; setHTML('displayProfileName', '2'); }
        appState.profile = p;

        if (p === "3" || p === "3+") {
            var fogOD = (raOD.s < 0) ? 2.00 : 2.25; 
            var fogOG = (raOG.s < 0) ? 2.00 : 2.25;
            appState.subj.OD = { sphere: raOD.s + fogOD, cyl: raOD.c, axe: raOD.a, va: "--" };
            appState.subj.OG = { sphere: raOG.s + fogOG, cyl: raOG.c, axe: raOG.a, va: "--" };
            appState.examPhase = "Sb0.2"; appState.targetVa = 0.06;
            if (appState.subj.OD.cyl === -0.25) { appState.memCyl.OD = { cyl: -0.25, axe: appState.subj.OD.axe }; appState.subj.OD.cyl = 0; appState.subj.OD.axe = 0; }
            if (appState.subj.OG.cyl === -0.25) { appState.memCyl.OG = { cyl: -0.25, axe: appState.subj.OG.axe }; appState.subj.OG.cyl = 0; appState.subj.OG.axe = 0; }
        } else if (p === "2") {
            var fogOD = (raOD.s < 0) ? 0.75 : 1.00; 
            var fogOG = (raOG.s < 0) ? 0.75 : 1.00;
            appState.subj.OD = { sphere: raOD.s + fogOD, cyl: raOD.c, axe: raOD.a, va: "--" };
            appState.subj.OG = { sphere: raOG.s + fogOG, cyl: raOG.c, axe: raOG.a, va: "--" };
            appState.examPhase = "Sb0.5"; appState.targetVa = 0.32;
        } else {
            var startEye = appState.firstEye; 
            var otherEye = (startEye === 'OD') ? 'OG' : 'OD';
            appState.subj[startEye] = { sphere: (startEye === 'OD' ? raOD.s : raOG.s), cyl: (startEye === 'OD' ? raOD.c : raOG.c), axe: (startEye === 'OD' ? raOD.a : raOG.a), va: "--" };
            appState.subj[otherEye] = { sphere: (otherEye === 'OD' ? raOD.s : raOG.s) + 0.75, cyl: (otherEye === 'OD' ? raOD.c : raOG.c), axe: (otherEye === 'OD' ? raOD.a : raOG.a), va: "--" };
            appState.examPhase = "Sb1.0"; appState.targetVa = 0.50;
        }

        // Commande magique pour le signe + :
        window.updateDisplay("Initialisation...");
        // Init Exam
        appState.isRunning = true;

        // CORRECTION : On ne remet surtout pas firstEye à 'OD'.
        // On utilise la valeur définie par le Schober (appState.firstEye).
        appState.activeEye = appState.firstEye;
        appState.defoggedInZone = false;
        setVaToIndexClosest(appState.targetVa); appState.startVaIndex = appState.vaIndex;

        // Reset flags
        appState.sb02_OD_ok=false; appState.sb02_OG_ok=false; appState.seen025_OD=false; appState.seen025_OG=false;
        appState.sb05_OD_ok=false; appState.sb05_OG_ok=false; appState.sb10_OD_ok=false; appState.sb10_OG_ok=false;
        appState.saved_sb10 = { OD: 0, OG: 0 };

        if (appState.profile === "2") { 
             appState.tqsFogCount = 0;
             appState.sb02_OD_ok = true; appState.sb02_OG_ok = true; 
        }
        else if (appState.profile === "1") { appState.sb02_OD_ok = true; appState.sb02_OG_ok = true; appState.sb05_OD_ok = true; appState.sb05_OG_ok = true; }

        // Affichage Zone
        document.getElementById('waitingMsg').classList.add('hidden');
        document.getElementById('examContent').classList.remove('hidden');
      // AFFICHER LA BARRE DE DONNÉES MAINTENANT (Début Examen)
        document.getElementById('examDataStrip').classList.remove('hidden');
        updateDisplay("Profil " + appState.profile + ". Phase " + appState.examPhase + " (OD)");

        say("Lisez moi s'il vous plait les lettres que vous voyez sur l'écran devant vous.");
    } catch(e) { alert("Erreur Lancement: " + e); }
};

// ... SUITE LOGIQUE (TargetEye, Validate, ProcessLogic...) ...
function getTargetEye() { return (appState.activeEye === 'OD') ? appState.subj.OD : appState.subj.OG; }

window.validateSb02 = function() {
    var eye = appState.activeEye;
    
    // 1. Verrouillage immédiat : on change de phase fictivement pour stopper les relances
    appState.examPhase = "TRANSITION"; 

    if (eye === 'OD') appState.sb02_OD_ok = true; 
    else appState.sb02_OG_ok = true;

    say("Bien, on va de l'autre côté.", function() {
        if (appState.sb02_OD_ok && appState.sb02_OG_ok) { 
            initSb05(); 
        } 
        else {
            var nextEye = (eye === 'OD') ? 'OG' : 'OD'; 
            
            // 2. Reset complet de l'état pour le second oeil
            appState.activeEye = nextEye;
            appState.examPhase = "Sb0.2"; // On remet la phase correcte
            appState.vaIndex = appState.startVaIndex; 
            appState.letterIndex = 0;
            appState.defoggedInZone = false;
            
            updateDisplay("Recherche Sb0.2 (" + nextEye + ")");
            
            // 3. Relance propre après un court délai
            setTimeout(function() {
                if (appState.isRunning) say(window.getRandomPrompt());
            }, 600);
        }
    });
};
function initSb05() {
    // ALERT REMOVED FOR FLUID TRANSITION
    // alert("Début Recherche Sb0.5 (T.Q.S).\nRetour au premier œil (" + appState.firstEye + ").");
    appState.examPhase = "Sb0.5"; 
    appState.activeEye = appState.firstEye; // Retour premier oeil
    appState.defoggedInZone = false; 
    appState.tqs_attempted_06 = false; 
    appState.count06_validations = 0; 
    appState.tqsFogCount = 0; 

    // APPLICATION DU DEBROUILLAGE GLOBAL (OD + OG)
    applySb05GlobalDefog();

    // AJOUT : Annonce de relance après l'initialisation de la phase
    say(window.getRandomPrompt());
}

function applySb05GlobalDefog() {
    if(appState.profile === "2") { 
        setVaToIndexClosest(0.32); 
        updateDisplay("Profil 2: Démarrage T.Q.S."); 
        return; 
    }

    // Calcul pour OD (Basé sur la sphère actuelle de fin de Sb0.2)
    if (appState.seen025_OD) {
        // A vu 0.25 -> Pas de débrouillage
    } else {
        // N'a pas vu 0.25 -> Débrouillage
        var currentSphOD = appState.subj.OD.sphere;
        var deltaOD = (currentSphOD < 0) ? -0.75 : -0.50; // Basé sur sphère actuelle
        appState.subj.OD.sphere += deltaOD;
    }

    // Calcul pour OG (Basé sur la sphère actuelle de fin de Sb0.2)
    if (appState.seen025_OG) {
        // A vu 0.25 -> Pas de débrouillage
    } else {
        // N'a pas vu 0.25 -> Débrouillage
        var currentSphOG = appState.subj.OG.sphere;
        var deltaOG = (currentSphOG < 0) ? -0.75 : -0.50; // Basé sur sphère actuelle
        appState.subj.OG.sphere += deltaOG;
    }

    setVaToIndexClosest(0.32); 
    updateDisplay("Sb0.5: Débrouillage Bilatéral effectué -> Départ 0.3");
}

function validateSb05() {
    var eye = appState.activeEye;
    if (eye === 'OD') appState.sb05_OD_ok = true; else appState.sb05_OG_ok = true;

    if(eye === 'OD') appState.saved_sb05.OD = appState.subj.OD.sphere; 
    else appState.saved_sb05.OG = appState.subj.OG.sphere;

    say("Bien, on va de l'autre côté.", function() {
        if (appState.sb05_OD_ok && appState.sb05_OG_ok) { 
            initSb10(); 
        } 
        else {
            var nextEye = (eye === 'OD') ? 'OG' : 'OD'; 
            appState.activeEye = nextEye;
            
            // --- SÉCURITÉ : On remet la phase Sb0.5 après la transition ---
            appState.examPhase = "Sb0.5"; 
            
            appState.count06_validations = 0; 
            appState.tqs_attempted_06 = false;
            appState.tqsFogCount = 0;

            setVaToIndexClosest(0.32); 
            updateDisplay("Sb0.5 (" + nextEye + ") : Départ 0.3");

            // Délai pour que le visuel s'installe avant la voix
            setTimeout(function() {
                if (appState.isRunning) say(window.getRandomPrompt());
            }, 500);
        }
    });
}

function initSb10() {
    // ALERT REMOVED FOR FLUID TRANSITION
    // alert("Passage à Sb1.0 (Bio-Monoculaire).");
    appState.examPhase = "Sb1.0"; appState.activeEye = appState.firstEye; appState.defoggedInZone = false;
    applySb10Logic();

    // AJOUT : Annonce de relance après l'initialisation de la phase
    say(window.getRandomPrompt());
}

function applySb10Logic() {
    var eye = appState.activeEye; 
    var target = getTargetEye(); 
    
    setVaToIndexClosest(0.50);

    var currentSphere = parseFloat(target.sphere);

    if (currentSphere < 0) {
        // MYOPE : Débrouille de -0.50 sur base Sb0.5
        var newSphere = currentSphere - 0.50;
        target.sphere = newSphere;
        updateDisplay("Sb1.0 Myope: Débrouille -0.50 (Base: " + currentSphere.toFixed(2) + " -> " + newSphere.toFixed(2) + ")");
    } else { 
        // HYPERMÉTROPE : On conserve STRICTEMENT la Sb0.5
        updateDisplay("Sb1.0 Hypermétrope: Conservation base Sb0.5 (" + currentSphere.toFixed(2) + ")"); 
    }
}
window.validateSb10 = function() {
    var target = getTargetEye();
    var lettersRead = appState.lastResponseCount; 
    var cadence = appState.lastCadenceUsed;
 // GARDE-FOU : Empêche de relancer Swéb uniquement pour le MYOPE
    if (appState.subj[appState.activeEye].swebDone && target.sphere < 0) {
        if (lettersRead >= 3) finishSb10ForEye();
        return true; 
    }
    const currentVA = ACUITY_TABLE[appState.vaIndex].va;

    // --- CONDITION COMMUNE : SEULEMENT AU 10/10 ---
    if (currentVA === 1.0) {

        if (target.sphere < 0) {
            // === LOGIQUE MYOPE (NÉGATIF) ===
            
            // A. Déclencheurs de la Vérification (Swéb)
            var triggerSweb = false;
            if (lettersRead === 3 && cadence === 'rabbit') triggerSweb = true;
            if (lettersRead === 4) triggerSweb = true;
            if (lettersRead === 5 && cadence !== 'rabbit') triggerSweb = true;

            // B. Déclencheurs du Débrouillage Simple (Sans test de gain)
            var triggerSimpleDefog = false;
            if (lettersRead <= 2) triggerSimpleDefog = true;
            if (lettersRead === 3 && cadence === 'turtle') triggerSimpleDefog = true;

           if (triggerSweb) {
                appState.scoreN_SansVerre = lettersRead;
                appState.isCheckingGain = true;
                appState.baseSphereValue = target.sphere;
                appState.examPhase = "Vérification de Swéb"; 
                
                // 1. On change la ligne techniquement
                if (goNextLine()) nextLetters(); else nextLetters();

                // 2. ON FORCE LA MISE À JOUR VISUELLE IMMÉDIATE (L'ajout est ici)
                var currentData = ACUITY_TABLE[appState.vaIndex];
                var txt = currentData.lines[appState.letterIndex % currentData.lines.length];
                updateVisualAcuityDisplay(currentData.va, txt);
                
                // 3. On met à jour l'indicateur de phase en haut
                updateDisplay("Vérification Myope à 1.0");

                // 4. On lance la voix
                say("Ce n'est pas moche. Voyons si on peut encore faire mieux. Lisez-moi cette nouvelle ligne.");
                
                return true; 
            }
            else if (triggerSimpleDefog) {
                target.sphere -= 0.25;
                appState.baseSphereValue = target.sphere;
                nextLetters();
                
                // Forcer l'affichage du changement de lettres (si changement de lettres il y a)
                var currentData = ACUITY_TABLE[appState.vaIndex];
                var txt = currentData.lines[appState.letterIndex % currentData.lines.length];
                updateVisualAcuityDisplay(currentData.va, txt);

                updateDisplay("Insuffisance à 1.0 -> Débrouillage -0.25");
                return true;
            }

        } else {
            // === LOGIQUE HYPERMÉTROPE (POSITIF) ===
            
            // 1. DÉCLENCHEUR VERRES VÉRIFICATEURS (3, 4 ou 5 lettres)
            // Dès que la ligne est "validée" ou "semi-validée", on teste le +0.25
            if (lettersRead >= 3) {
                initSphereCheckPlus(); 
                return true; 
            } 
            // 2. DÉBROUILLAGE SIMPLE (0, 1 ou 2 lettres)
            // Le patient ne voit rien ou presque : on augmente la puissance
            else {
                // On utilise la logique standard pour baisser la sphère (débrouiller)
                processLogic(lettersRead, cadence);
                return true;
            }
        }
    } else {
        // HORS LIGNE 1.0 : Logique de progression standard
        processLogic(lettersRead, cadence);
      return true;
    }
  return false;
};
  
  /*window.launchDirectSwebForMyope = function() {
    const target = getTargetEye();
    // 1. On mémorise le score actuel avant de changer de ligne
    appState.scoreN_SansVerre = appState.lastResponseCount || 0;
    appState.isCheckingGain = true;
    appState.baseSphereValue = target.sphere;

    if (goNextLine()) {
        appState.examPhase = "Vérification de Swéb";
        nextLetters();
        
        // REPERE : Rafraîchissement forcé de l'interface
        window.updateDisplay("Vérification de Swéb (Mesure de base)");
        
        // On s'assure que les boutons ronds sont cachés et les chiffres (0-5) visibles
        document.getElementById('checkPlusZone').classList.add('hidden');
        document.getElementById('standardButtons').classList.remove('hidden');
        
        // --- NOUVEAU MESSAGE POUR MYOPE UNIQUEMENT ---
        say("C'est pas trop moche. Voyons si on peut faire encore un peu mieux sur cette nouvelle ligne.");
    } else {
        appState.examPhase = "Vérification de Swéb";
        nextLetters();
        window.updateDisplay("Vérification finale");
        say("C'est déjà excellent. Relisez-moi ces lettres pour confirmer.");
    }
};*/
  
window.finishSb10ForEye = function() {
    window.hideBaseCircle();
    var eye = appState.activeEye;
    var target = getTargetEye();
    var maxVa = ACUITY_TABLE[appState.vaIndex].va;
    
    appState.subj[eye].va = maxVa;
    // On force l'affichage VA
    setHTML('disp_subj' + eye + '_va', formatVA(maxVa));

    // Sauvegarde de la sphère rectifiée (+2.00)
    if (eye === 'OD') appState.saved_sb10.OD = target.sphere; 
    else appState.saved_sb10.OG = target.sphere;
    
    if (eye === 'OD') appState.sb10_OD_ok = true; 
    else appState.sb10_OG_ok = true;

    appState.examPhase = "Validation_Intermédiaire"; 

    // --- AJOUT DE SÉCURITÉ ICI ---
    // Cette ligne force le dashboard à afficher le +2.00 immédiatement
    updateDisplay("Fin de la recherche de sphère."); 
    // -----------------------------

    var puissanceCyl = Math.abs(target.cyl);

    if (puissanceCyl === 0) {
        say("C'est parfait, cet oeil est terminé.", function() {
            window.proceedToNextStepAfterEye(eye); 
        });
    } else {
        appState.examPhase = "AxisCheck"; 
        document.getElementById('checkPlusZone').classList.add('hidden');
        document.getElementById('standardButtons').classList.add('hidden');
        document.getElementById('axisZone').classList.remove('hidden');
        initAxisCheck();
    }
};
window.proceedToNextStepAfterEye = function(completedEye) {
    var otherEye = (completedEye === 'OD') ? 'OG' : 'OD';
    var isOtherEyeDone = (otherEye === 'OD') ? appState.sb10_OD_ok : appState.sb10_OG_ok;

    if (!appState.isMonocularExam && !isOtherEyeDone) {
        // 1. Reset des drapeaux de sécurité pour le nouvel oeil
        appState.isCheckingGain = false; 
        appState.safety_mode = false;    
        appState.sb10_line_defog = 0;    
        appState.hasRestartedSb10 = false;
        appState.tqsFogCount = 0;
        appState.subj[otherEye].swebDone = false; // Permet Swéb sur le second œil
        appState.fogTotalAdded = 0;               // <--- LIGNE À AJOUTER
        appState.retestCount = 0;                 // <--- LIGNE À AJOUTER

       // 2. BROUILLAGE DE L'OEIL PASSIF (O1)
        // On récupère la Sb0.5 enregistrée (Profil 2/3)
        var sb05_mesuree = (completedEye === 'OD') ? appState.saved_sb05.OD : appState.saved_sb05.OG;
        
        // Si on a une vraie mesure (Profil 2, 3), on l'utilise. 
        // Sinon (Profil 1), on calcule le théorique.
        if (sb05_mesuree && sb05_mesuree !== 0) {
            appState.subj[completedEye].sphere = sb05_mesuree;
        } else {
            var raSphO1 = getVal('ra' + completedEye + '_sph');
            appState.subj[completedEye].sphere = raSphO1 + 0.75;
        }

        // 3. PRÉPARATION DE L'OEIL ACTIF (O2)
        // On ne touche PAS à appState.subj[otherEye].sphere ! 
        // Il contient déjà la valeur Sb0.5 trouvée précédemment.

        appState.activeEye = otherEye;
        appState.examPhase = "Sb1.0";
        
        applySb10Logic(); 
        updateDisplay("Bascule vers " + otherEye + " (Oeil " + completedEye + " brouillé à RA+0.75)");
        say("Bien, nous passons à l'examen de l'autre œil.");
    } else {
        say("L'examen monoculaire est terminé. Passons à la suite.");
        updateDisplay("Phase Monoculaire Terminée");
    }
};
  
  function initSphereCheckMinus() {
  window.showBaseCircle(); // <--- AJOUTER CETTE LIGNE
    appState.examPhase = "SphereCheckMinus"; appState.checkStep = "TEST_125_PRE";

    // MODIFICATION: Check si safety mode actif
    if (appState.safety_mode) {
        // En mode sécurité, on reste sur la ligne actuelle
        // Mais on change les lettres pour éviter la mémorisation
        nextLetters();
        updateDisplay("Sécurité Myope: Test Quart Concave sur ligne actuelle.");

        // --- LOGIQUE: ON AJOUTE LE -0.25 POUR LE TEST ---
        var target = getTargetEye(); 
        target.sphere -= 0.25; 
        // ------------------------------------------------

        say("Lisez-moi cette ligne maintenant."); // Vocal spécifique demandé
    } else {
        // Mode standard (fin d'examen), on va à 1.25
        setVaToIndexClosest(1.25); 
        updateDisplay("Check (-): Lecture 1.25 (Score 1)");
    }
}

function initSphereCheckPlus(skipIntro) {
    window.showBaseCircle(); 
    appState.examPhase = "SphereCheckPlus"; 
    appState.baseSphereValue = getTargetEye().sphere;
    
    document.getElementById('standardButtons').classList.add('hidden');
    document.getElementById('cadenceButtons').classList.add('hidden');
    document.getElementById('checkPlusZone').classList.remove('hidden');
    document.getElementById('stepPlusWrapper').classList.remove('hidden');
    document.getElementById('decisionsPlus').classList.add('hidden');
    document.getElementById('stepMinusWrapper').classList.add('hidden');
    document.getElementById('decisionsMinus').classList.add('hidden');

    if (skipIntro) {
        // --- ON NE DIT RIEN, ON LANCE JUSTE LE TEST ---
        nextLetters(); 
        window.triggerFogCheck(); 
    } else {
        // --- INTRODUCTION LONGUE UNIQUEMENT LA PREMIÈRE FOIS ---
        setTimeout(function() { 
            say("C'est pas mal, mais on va essayer de faire un peu mieux", function() { 
                nextLetters(); 
                window.triggerFogCheck(); 
            }); 
        }, 500); 
    }
}
  /*window.initQuartConcaveMyope = function() {
    // 1. VERROUILLAGE DE LA PHASE (PRIORITÉ ABSOLUE)
    appState.examPhase = "QuartConcaveMyope"; 

    // 2. Initialisation des données
    window.showBaseCircle(); 
    appState.baseSphereValue = getTargetEye().sphere;

    // 3. Configuration de l'interface
    document.getElementById('standardButtons').classList.add('hidden');
    document.getElementById('cadenceButtons').classList.add('hidden');
    document.getElementById('checkPlusZone').classList.remove('hidden');
    
    document.getElementById('stepPlusWrapper').classList.add('hidden');
    document.getElementById('stepMinusWrapper').classList.remove('hidden');
    document.getElementById('decisionsMinus').classList.add('hidden');

    // 4. Lancement vocal et animation
    setTimeout(function() {
        say("On va essayer d'améliorer encore un peu la netteté.", function() {
            nextLetters(); 
            window.triggerDefogCheck(); 
        });
    }, 500);
};*/
// --------------------------------------------------------------------------
// --- LOGIQUE ASYNCHRONE ET TIMING PRÉCIS (Basé sur Analyse Vidéo) ---
// --------------------------------------------------------------------------

// 1. Fonction utilitaire pour attendre (Promesse)
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// 2. Test du +0.25 (3s d'exposition environ - Ratio 2:1)
// --- FONCTION TEST +0.25 (AVEC NOUVEAU SCHÉMA BULLES) ---
// --- FONCTION TEST +0.25 (AVEC ANIMATION FLÈCHE GAUCHE) ---
async function triggerFogCheck() {
    updateLockUI(true);
    document.getElementById('btnPlus025').disabled = true; 
    
    // S'assurer que le bouton bleu est bien là au début
    window.showBaseCircle(); 
    
    const target = getTargetEye();
    target.sphere = appState.baseSphereValue; 
    updateDisplay("Check (+): Référence...");

    var arrow = document.getElementById('animArrowLine');
    var targetBubble = document.getElementById('animTargetCircle');

    say("Vous préférez comme ça ?");
    await wait(2500); 

    say("Ou si je fais ça ?");
    await wait(400); 
    
    if(arrow) arrow.classList.add('active');
    if(targetBubble) targetBubble.classList.add('visible');
    
    target.sphere = appState.baseSphereValue + 0.25;
    updateDisplay("Check (+): +0.25 ajouté");

    await wait(3000); 

    say("Ou si je reviens ?");
    await wait(400);


    target.sphere = appState.baseSphereValue; 
    updateDisplay("Check (+): Retour Base");
await wait(1000); 
   // >>> DISPARITION DU BOUTON ET DES BULLES ICI <<<
    window.hideBaseCircle(); 
  
    await wait(1000); 

    updateLockUI(false);
    document.getElementById('decisionsPlus').classList.remove('hidden'); 
    document.getElementById('btnPlus025').disabled = false;
}
  
  // 3. Test du -0.25 (1.5s d'exposition environ - Ratio 1:2)
// --- FONCTION TEST -0.25 (ANIMATION VERS LA DROITE) ---
async function triggerDefogCheck() {
    updateLockUI(true);
    document.getElementById('btnMinus025').disabled = true; 
    
    // S'assurer que le bouton bleu est bien là au début
    window.showBaseCircle();

    const target = getTargetEye();
    target.sphere = appState.baseSphereValue;
    updateDisplay("Check (-): Référence...");

    var arrowMinus = document.getElementById('animArrowLineMinus');
    var targetBubbleMinus = document.getElementById('animTargetCircleMinus');

    say("Vous préférez comme ça ?");
    await wait(2500);

    say("Ou si je fais ça ?");
    await wait(400);
    
    if(arrowMinus) arrowMinus.classList.add('active');
    if(targetBubbleMinus) targetBubbleMinus.classList.add('visible');

    target.sphere = appState.baseSphereValue - 0.25;
    updateDisplay("Check (-): -0.25 ajouté");

    await wait(1500); 

    say("Ou si je reviens ?");
    await wait(400);

    target.sphere = appState.baseSphereValue; 
    updateDisplay("Check (-): Retour Base");
await wait(1000); 
  // >>> DISPARITION DU BOUTON ET DES BULLES ICI <<<
    window.hideBaseCircle();

    await wait(1000); 

    updateLockUI(false);
    document.getElementById('decisionsMinus').classList.remove('hidden'); 
    document.getElementById('btnMinus025').disabled = false;
}
  
 window.relaunchPlus = function() {
    if (appState.isSpeaking) return;
    document.getElementById('decisionsPlus').classList.add('hidden');
    
    appState.retestCount = (appState.retestCount || 0) + 1;

    if (appState.retestCount >= 2) {
        say("D'accord. Pour vous aider, je vais vous demander de me lire les lettres à haute voix avec chacun des verres. On commence par le premier.", function() {
            window.triggerFogCheck();
        });
        appState.retestCount = 0; // Reset
    } else {
        nextLetters();
        say("D'accord, je vous remontre", function() { 
            window.triggerFogCheck(); 
        });
    }
};

window.decidePlus = function(choice) {
    if (appState.isSpeaking) return;

    const target = getTargetEye();
    const currentSph = target.sphere;
    const raSph = (appState.activeEye === 'OD') ? getVal('raOD_sph') : getVal('raOG_sph');

    if (choice === 'better' || choice === 'same') {
        document.getElementById('decisionsPlus').classList.add('hidden');
        appState.isCheckingGain = false;
        
        // 1. Mise à jour de la sphère et du compteur de cumul
        target.sphere = appState.baseSphereValue + 0.25;
        appState.baseSphereValue = target.sphere;
        appState.fogTotalAdded += 0.25; 

        // 2. Sécurité : Alerte si le brouillage atteint 1.00 D
        if (appState.fogTotalAdded >= 1.00) {
            let messageAlarme = "";
            let btnText = "";
            
            if (appState.profile === "1" || appState.profile === "2") {
                messageAlarme = "Le patient accepte un brouillage trop important (+1.00 D). Il est conseillé de recommencer l'examen en <b>Profil 3 (Difficile)</b> pour bloquer l'accommodation.";
                btnText = "PASSER EN PROFIL 3";
            } else {
                messageAlarme = "Malgré un protocole rigoureux, l'accommodation reste instable (+1.00 D de brouillage accepté). Il est recommandé de passer sous <b>Cycloplégique</b>.";
                btnText = "STOP : PROTOCOLE CYCLO";
            }

            Swal.fire({
                title: "Brouillage excessif",
                html: messageAlarme,
                icon: 'warning',
                confirmButtonText: btnText,
                confirmButtonColor: '#D32F2F',
                allowOutsideClick: false
            }).then((result) => {
                if (result.isConfirmed) {
                    if (appState.profile === "1" || appState.profile === "2") {
                        appState.initProfile = "3";
                        window.restartExam(); 
                    } else {
                        window.prepareCycloStop();
                    }
                }
            });
            return; 
        }

        // 3. Suite normale si le seuil n'est pas atteint
        nextLetters();
        updateDisplay("Brouillage accepté (+ " + appState.fogTotalAdded.toFixed(2) + ")");
        say("D'accord, je vous remontre", function() {
            window.triggerFogCheck();
        });
    } else {
        // --- CAS : REJET DU +0.25 ---
        const isRaPositiveAtZero = (raSph >= 0 && currentSph <= 0);

        if (isRaPositiveAtZero) {
            updateDisplay("Validation : Limite 0.00 atteinte");
            if(document.getElementById('checkPlusZone')) document.getElementById('checkPlusZone').classList.add('hidden');
            say("Ok, on continue.", function() {
                finishSb10ForEye(); 
            });
        } 
        else {
            // CORRECTIF : On prépare le terrain pour le MOINS
            document.getElementById('stepPlusWrapper').classList.add('hidden'); 
            document.getElementById('stepMinusWrapper').classList.remove('hidden');
            document.getElementById('decisionsMinus').classList.add('hidden');
            
            updateDisplay("Rejet (+) -> Présentation du Quart Concave (-0.25)");
            
            say("Attention, je vais dans l'autre sens.", function() { 
                // On lance l'animation visuelle du verre de -0.25
                window.triggerDefogCheck(); 
            });
        }
    }
}  
  window.startAutomaticMinusCheck = function() {
    document.getElementById('stepMinusWrapper').classList.remove('hidden');
    document.getElementById('decisionsMinus').classList.add('hidden');
    window.triggerDefogCheck();
};

window.relaunchFullCheck = function() { 
    if (appState.isSpeaking) return; // LOCK

    // Relance explicite -> Changement de lettres
    nextLetters();

    say("D'accord, mais on refait tout", function() { window.initSphereCheckPlus(true); }); 
};

window.decideMinus = function(choice) {
    if (appState.isSpeaking) return;

    if (choice === 'better') {
        const eye = appState.activeEye;
        const baseVA = parseFloat(appState.subj[eye].va); // Acuité mémorisée au palier

        appState.scoreN_SansVerre = appState.lastResponseCount || 0;
        appState.isCheckingGain = true;

        // --- LOGIQUE DE SYNCHRONISATION ---
        if (baseVA < 1.0) {
            // Si on vient d'un plateau (ex: 0.6), on force Swéb sur la ligne d'après (0.8)
            setVaToIndexClosest(baseVA); 
            goNextLine(); 
            updateDisplay("Vérification de Swéb adaptée au palier " + formatVA(baseVA));
        } else {
            // Sinon (Cas standard à 1.0), on monte normalement au 1.25
            if (!goNextLine()) {
                // Sécurité si déjà au maximum du tableau
                finishSb10ForEye();
                return;
            }
            updateDisplay("Vérification de Swéb standard");
        }

        appState.examPhase = "Vérification de Swéb"; 
        nextLetters(); 
        
        document.getElementById('checkPlusZone').classList.add('hidden');
        document.getElementById('standardButtons').classList.remove('hidden');
        
        say("D'accord. Mais il faut me le prouver. Lisez-moi cette nouvelle ligne s'il vous plaît.");
    } else {
        // --- CAS : REJET DU -0.25 (Sortie définitive de la sphère) ---
        appState.isCheckingGain = false;

        // Rétablissement de la sphère de base (celle validée avant le test)
        var target = getTargetEye();
        target.sphere = appState.baseSphereValue; 
        
        updateDisplay("Refus du -0.25. Réglage final validé.");

        if(document.getElementById('checkPlusZone')) 
            document.getElementById('checkPlusZone').classList.add('hidden');
        
        // Sortie vers l'astigmatisme
        say("Très bien, continuons.", function() {
            finishSb10ForEye(); 
        });
    }
};
  
 window.handleResponse = function(lettersRead) {
    if (appState.isSpeaking) return; 
    appState.lastResponseCount = lettersRead;
    window.cleanAndSyncVA(lettersRead); 

    // =========================================================
    // --- CONTROLE QUALITÉ : VÉRIFICATION DE L'AXE ---
    // =========================================================
    if (appState.examPhase === "AxisVerification") {
    appState.isSpeaking = true;
    updateLockUI(true);

    if (lettersRead < appState.lettersBeforeAxis) {
        // --- CHANGEMENT DE PHASE IMMÉDIAT (AVANT LA VOIX) ---
        appState.examPhase = "AxisCheck"; 
        
        var target = getTargetEye();
        target.axe = appState.axisInitialRA; // Reset à la valeur RA
        
        // Réinitialisation des paramètres techniques
        appState.axisRepeatCount = 0;
        appState.axisDirectionHistory = [];
        appState.axisStep = (Math.abs(target.cyl) < 2.50) ? 20 : 10;

        // Mise à jour visuelle instantanée du tableau de bord
        updateDisplay("Échec de validation : retour à la mise au point de l'axe.");

        // Lancement de la voix (le visuel est déjà à jour)
        say("C'est curieux vous voyez moins bien. Nous allons recommencer.", function() {
            appState.isSpeaking = false;
            updateLockUI(false);

            // Gestion de l'affichage des zones JCC
            document.getElementById('standardButtons').classList.add('hidden');
            document.getElementById('axisControls').classList.remove('hidden');
            document.getElementById('jccVisuals').classList.remove('hidden');

            // Lancement de la séquence de comparaison
            setTimeout(function() { runJccSequence(); }, 1000);
        });
    } else {
        // SUCCÈS : Vision égale ou meilleure
        say("Très bien, je vous montre deux nouvelles positions.", function() {
            appState.isSpeaking = false;
            updateLockUI(false);
            window.proceedToNextStepAfterEye(appState.activeEye);
        });
    }
    return; 
}
    var wordsLow = ["Ok", "D'accord", "Bien"];
    var feedback = wordsLow[Math.floor(Math.random() * wordsLow.length)];

    // --- PHASE Sb0.2 & Sb0.5 ---
    if (appState.examPhase === "Sb0.2" || appState.examPhase === "Sb0.5") {
        say(feedback, function() {
            processLogic(lettersRead, 'rabbit');
            if (appState.examPhase !== "TRANSITION") {
                setTimeout(function() { 
                    say(window.getRandomPrompt()); 
                }, 300);
            } else {
                appState.isSpeaking = false;
                updateLockUI(false);
            }
        }, true); 
        return;
    }

    // --- PHASE Sb1.0 (RECHERCHE 10/10) ---
    if (lettersRead < 3) {
        appState.isSpeaking = true; 
        updateLockUI(true); 

        say(feedback, function() {
            var isIntercepted = window.validateSb10(); 
            if (!isIntercepted) processLogic(lettersRead, 'rabbit');

            setTimeout(function() {
                if (appState.isRunning && appState.examPhase === "Sb1.0" && !appState.isCheckingGain) {
                    var prompt = (lettersRead === 0) ? 
                        "C'est normal. Je change de verre. Est-ce que c'est mieux comme ça ?" : 
                        "Je change de verre. Relisez-moi cette ligne s'il vous plaît.";
                    
                    say(prompt, function() {
                        appState.isSpeaking = false;
                        updateLockUI(false);
                    });
                } else {
                    appState.isSpeaking = false;
                    updateLockUI(false);
                }
            }, 400); 
        }, true);
        return;
    } else { 
        say(feedback); 
        askCadence(lettersRead); 
    }
};
  window.handleCadence = function(type) {
    if (appState.isSpeaking) return; 

    appState.lastCadenceUsed = type;
    var n = appState.pendingLetters; 
    appState.pendingLetters = null;

    document.getElementById('standardButtons').classList.remove('hidden'); 
    document.getElementById('cadenceButtons').classList.add('hidden');

    // 1. On vérifie si validateSb10 intercepte le score (ex: 4 lapin à 1.0)
    var intercepted = window.validateSb10();

    // 2. Si non intercepté, on lance la logique standard (ex: 0.8 validé -> 1.0)
    if (!intercepted) {
        processLogic(n, type);
    }

    // 3. RÉTABLISSEMENT DE LA RELANCE :
    // Si on est toujours en phase Sb1.0, on lance la phrase de relance
    if (appState.examPhase === "Sb1.0") {
        say(window.getRandomPrompt());
    }
};

// --- LOGIQUE PRINCIPALE AVEC MESSAGES HARMONISÉS ---
  function processLogic(lettersRead, cadence) {
    // --- AJOUT SÉCURITÉ : REDIRECTION VERS LE CALCUL DE SWÉB ---
    if (appState.examPhase.includes("Vérification de Swéb")) {
        // Si on est dans cette phase, on ignore la logique standard
        // et on laisse les blocs spécialisés (CAS 1, 2, 3) gérer le calcul de gain.
        // On s'assure juste que le score est mémorisé.
        console.log("Logique Swéb détectée pour score : " + lettersRead);
    }
    // ----------------------------------------------------------

    var currentVA = ACUITY_TABLE[appState.vaIndex].va;
    // --- AJOUT DE LA RÈGLE DU GAIN ---
    
    // ---------------------------------
    
    var currentVA = ACUITY_TABLE[appState.vaIndex].va;
    // ... reste de la fonction
    var currentVA = ACUITY_TABLE[appState.vaIndex].va;
    var currentTxt = ACUITY_TABLE[appState.vaIndex].lines[appState.letterIndex % 8]; if(!currentTxt) currentTxt = ACUITY_TABLE[appState.vaIndex].lines[0];
    var totalLetters = currentTxt.split(' ').length; var isSmallLine = totalLetters < 5;
    var isPassed = false;

  // =========================================================
// =========================================================
// =========================================================
// LOGIQUE EXPERTE : VÉRIFICATION DE SWÉB (SÉCURISÉE)
// =========================================================

// --- LOGIQUE HARMONISÉE : VÉRIFICATION DE SWÉB ---

// ÉTAPE 1 : Mesure sans le -0.25 (sur la ligne 1.25)
if (appState.examPhase === "Vérification de Swéb") {
    appState.scoreNPlus1_SansVerre = lettersRead; 

// --- CORRECTION BUG BOUCLE INFINIE ---
    // Si le patient voit déjà tout (5 lettres) SANS le verre de -0.25
    if (lettersRead >= 5) {
        appState.isCheckingGain = false;
        appState.subj[appState.activeEye].va = ACUITY_TABLE[appState.vaIndex].va;
        
        say("C'est parfait, votre acuité augmente déjà. Vérifions si on peut encore faire mieux.", function() {
            initSphereCheckPlus(true); // Rebouclage immédiat
        });
        return;
    }
    // --------------------------------------
  
    var target = getTargetEye();
    target.sphere = appState.baseSphereValue - 0.25; 
    appState.examPhase = "Vérification de Swéb_AVEC_VERRE";
    
    nextLetters(); 
    updateDisplay("Vérification de Swéb (Test avec -0.25)");

    if (target.sphere < 0) {
        say("Bien. Et maintenant, est-ce que c'est mieux avec ce verre ? Relisez la ligne.");
    } else {
        say("Bien. Et maintenant avec ce nouveau verre, relisez cette ligne s'il vous plaît.");
    }
    return; 
}

// ÉTAPE 2 : Mesure AVEC le -0.25 et calcul du gain
    
    // --- ÉTAPE 2 : Mesure AVEC le -0.25 et calcul du gain ---
if (appState.examPhase === "Vérification de Swéb_AVEC_VERRE") {
    appState.scoreNPlus1_AvecVerre = lettersRead;
    var gainSurNPlus1 = appState.scoreNPlus1_AvecVerre - appState.scoreNPlus1_SansVerre;
    
    if (gainSurNPlus1 >= 3) {
       // SUCCÈS DU GAIN
        appState.isCheckingGain = false;
        const target = getTargetEye();
        // On ne verrouille QUE si le patient est myope
        if (target.sphere < 0) appState.subj[appState.activeEye].swebDone = true;
        
        // On valide le verre
        target.sphere = appState.baseSphereValue - 0.25; 
        appState.baseSphereValue = target.sphere; 
        
 // On met à jour la VA
        appState.subj[appState.activeEye].va = ACUITY_TABLE[appState.vaIndex].va;
        const currentVA = ACUITY_TABLE[appState.vaIndex].va;

        // --- LOGIQUE DE SORTIE DIFFÉRENCIÉE ---
        if (target.sphere < 0) {
            // MYOPE : Validation immédiate et sortie (votre règle)
            say("C'est parfait, ce verre est validé. Nous avons terminé la sphère.", function() {
                finishSb10ForEye(); 
            });
        } else {
            // HYPERMÉTROPE : On continue vers le +0.25 SAUF si on est au max du tableau
            if (currentVA >= 2.0) {
                say("Parfait, votre vision est maximale. La recherche de sphère est terminée.", function() {
                    finishSb10ForEye(); 
                });
            } else {
                say("C'est parfait. Vérifions si on peut encore améliorer votre vue.", function() {
                    initSphereCheckPlus(true); 
                });
            }
        }

    } else if (appState.scoreN_SansVerre < 5) {
        // ÉCHEC SUR N+1 : On teste le gain cumulé sur N
        var previousVA = ACUITY_TABLE[appState.vaIndex - 1].va;
        setVaToIndexClosest(previousVA);  
        appState.examPhase = "Vérification de Swéb_CUMUL_FINAL";
        nextLetters();
        updateDisplay("Vérification de Swéb (Gain cumulé sur ligne N)");
        say("D'accord. c'est un peu difficle; lisez moi ces lettres là s'il vous plaît.");
    } else {
        // ÉCHEC TOTAL : On rend le verre et on finit la sphère
        revertMinusLens();
    }
    return;
}
// ÉTAPE 3 : Gain cumulé (si nécessaire)
if (appState.examPhase === "Vérification de Swéb_CUMUL_FINAL") {
    var gainTotal = (lettersRead - appState.scoreN_SansVerre) + (appState.scoreNPlus1_AvecVerre - appState.scoreNPlus1_SansVerre);
    
    // --- NOUVEAU BLOC À INSÉRER ---
if (gainTotal >= 3) {
    appState.isCheckingGain = false;
    const target = getTargetEye();
    
    // 1. Verrouillage si myope
    if (target.sphere < 0) appState.subj[appState.activeEye].swebDone = true;

    // 2. Validation de la nouvelle sphère
    target.sphere = appState.baseSphereValue - 0.25;
    appState.baseSphereValue = target.sphere;

    // --- LOGIQUE DE SORTIE DIFFÉRENCIÉE (Étape 3) ---
    if (target.sphere < 0) {
        // MYOPE : Sortie immédiate
        say("Très bien, on continue.", function() {
            finishSb10ForEye();
        });
    } else {
        // HYPERMÉTROPE : ON PROGRESSE !
        // On valide officiellement la ligne supérieure (N+1)
        if (goNextLine()) {
            updateDisplay("Gain cumulé prouvé : passage à l'acuité " + ACUITY_TABLE[appState.vaIndex].va);
            say("Très bien, votre vision s'améliore. Voyons si on peut faire encore mieux.", function() {
                initSphereCheckPlus(true); // Relance les vérificateurs sur la nouvelle ligne
            });
        } else {
            // Cas où on était déjà au max du tableau
            finishSb10ForEye();
        }
    }
} else {
    // ÉCHEC DU GAIN : On rejette le -0.25, on revient à la base et on FINIT LA SPHÈRE
    revertMinusLens(); 
}
    return;
}
   // --- RÈGLE SPÉCIFIQUE SB0.2 (VALIDATION FINALE FIXÉE) ---
    if (appState.examPhase === "Sb0.2") {
        if (cadence === 'rabbit') {
            if (isSmallLine) {
                if (lettersRead === totalLetters) isPassed = true;
            } else {
                if (lettersRead >= 3) isPassed = true;
            }
        } else if (cadence === 'turtle') {
            if (!isSmallLine && lettersRead >= 4) isPassed = true;
        }

        if (isPassed) {
            // On enregistre le succès de la ligne actuelle (ex: 0.20)
            appState.subj[appState.activeEye].va = currentVA;
            
            var status = goNextLine(); 

            if (status === false) {
                // IMPORTANT : On rafraîchit l'interface pour afficher le 0.20
                // AVANT que validateSb02 ne lance la transition vocale.
                updateDisplay("2/10 Validé. Passage à l'autre œil...");
                return; 
            }

            updateDisplay("Validé " + currentVA + " -> Suivant");
            return;
          
        } else {
            // GESTION ÉCHEC AU 0.25 SANS DÉBROUILLAGE PRÉALABLE
            if (currentVA === 0.25 && !appState.defoggedInZone) {
                updateDisplay("Échec 2.5/10 -> Validation du palier 2/10.");
                setTimeout(function() { validateSb02(); }, 600);
                return;
            }

            // Débrouillage classique
            var currentSph = getTargetEye().sphere;
            var raSph = (appState.activeEye === 'OD') ? getVal('raOD_sph') : getVal('raOG_sph');
            
            if (currentSph - 0.25 < raSph) {
                 document.getElementById('modalDefogLimit').classList.remove('hidden');
                 return;
            }

            if (currentVA <= 0.20) appState.defoggedInZone = true;

            getTargetEye().sphere -= 0.25;
            if (lettersRead >= 3 || (isSmallLine && lettersRead > 0)) nextLetters();

            updateDisplay("Débrouillage -0.25");
            return;
        }
    }
  
    // RÈGLE SPÉCIFIQUE SB0.5 (T.Q.S)
    if (appState.examPhase === "Sb0.5") {

        // --- 1. Gestion Validation Ligne (Lapin/Tortue identique) ---
        if (lettersRead >= 3) isPassed = true;
        else isPassed = false;

        // --- 2. Logique par Ligne ---

        // CAS A : Ligne 0.3 (0.32) ou 0.4 (0.40)
        if (currentVA === 0.32 || currentVA === 0.40) {
            if (isPassed) {
                // MISE A JOUR VA LUE
                appState.subj[appState.activeEye].va = currentVA;

                if (currentVA === 0.40) {
                    if (appState.tqs_attempted_06) {
                        setVaToIndexClosest(0.50);
                        updateDisplay("0.4 Validé (Post-Brouillage) -> 0.5");
                    } else {
                        setVaToIndexClosest(0.60);
                        updateDisplay("0.4 Validé -> Saut à 0.6 (Piège)");
                        appState.tqs_attempted_06 = true; 
                    }
                } else {
                    goNextLine(); // 0.3 -> 0.4
                    updateDisplay("0.3 Validé -> 0.4");
                }
            } else {
                getTargetEye().sphere -= 0.25;
                nextLetters(); // <-- Ajout pour relance vocale
                updateDisplay("Échec " + currentVA + " -> Débrouille -0.25");
            }
            return;
        }

        // CAS B : Ligne 0.60 (Le Piège)
        if (currentVA === 0.60) {
            if (!isPassed) {
                if (appState.tqsFogCount > 0) setVaToIndexClosest(0.40);
                else setVaToIndexClosest(0.50);
                updateDisplay("Piège 0.6 fonctionnel -> Descente");
            } else {
                // MISE A JOUR VA LUE (Même si c'est un piège, il l'a lue)
                appState.subj[appState.activeEye].va = currentVA;

                if (appState.tqsFogCount >= 2) {
                    document.getElementById('modalTqsLimit').classList.remove('hidden');
                    return;
                }
                getTargetEye().sphere += 0.50;
                nextLetters();
                appState.tqsFogCount++;
                updateDisplay("Piège 0.6 échoué (Vu) -> Brouille +0.50");
            }
            return;
        }

      // CAS C : Ligne 0.50 (Validation Finale de la phase)
        if (currentVA === 0.50) {
            if (isPassed) {
                // 1. On valide visuellement le 0.50 dans le cadran
                appState.subj[appState.activeEye].va = currentVA;
                
                // 2. On verrouille la phase pour la transition vocale
                appState.examPhase = "TRANSITION";
                
                // 3. On force l'affichage final avant de changer d'œil
                updateDisplay("0.5 validé. Phase Sb0.5 terminée.");
                
                // 4. On lance la sortie de phase
                validateSb05();
            } else {
                // Échec au 0.50 : débrouillage classique
                getTargetEye().sphere -= 0.25;
                nextLetters(); 
                updateDisplay("Échec 0.5 -> Débrouille -0.25");
            }
            return;
        }
    }

    // RÈGLES STANDARD (AUTRES PHASES)
    if (cadence === 'rabbit') {
        if (isSmallLine && lettersRead === totalLetters) isPassed = true;
        if (!isSmallLine && lettersRead > 3) isPassed = true;
    }

    // LOGIQUE SPHERE CHECK
    if (appState.examPhase === "SphereCheckMinus") {
        if (appState.checkStep === "TEST_125_PRE") {
            appState.tempScore = lettersRead; var target = getTargetEye(); target.sphere -= 0.25;
            appState.checkStep = "TEST_125_POST"; nextLetters(); updateDisplay("Ajout -0.25 -> Relire 1.25");
        } else if (appState.checkStep === "TEST_125_POST") {
            var gain = lettersRead - appState.tempScore;

            // --- SÉCURITÉ MYOPE : RÈGLE GAIN >= 2 ---
            if (appState.safety_mode) {
                 var gainSafety = lettersRead - appState.safety_mem_letters;

                 if (gainSafety >= 2) {
                      // SUCCÈS : On garde le -0.25
                      if (isPassed) {
                           appState.safety_mode = false;
                           appState.sb10_line_defog = 0;
                           appState.examPhase = "Sb1.0"; // Retour Sb1.0
                           appState.subj[appState.activeEye].va = currentVA;
                           appState.checkStep = null;
                           if (goNextLine()) updateDisplay("Sécurité Myope passée -> Ligne Suivante");
                           else updateDisplay("Max Atteint");
                      } else {
                           // Pas lapin mais gain >= 2 -> On valide cette sphère
                           alert("Amélioration confirmée (+"+gainSafety+") mais plafond atteint. On valide cette sphère.");
                           finishSb10ForEye();
                      }
                 } else {
                      // ECHEC : Gain < 2
                      var target = getTargetEye(); target.sphere += 0.25; // Revert
                      updateDisplay("Revert...");
                      alert("Gain insuffisant (< 2). On revient à la sphère précédente.");
                      finishSb10ForEye();
                 }
                 return;
            }
            // ----------------------------------------

            if (gain >= 3) { updateDisplay("Gain suffisant -> -0.25 conservé"); appState.examPhase = "Sb1.0"; appState.checkStep = null; finishSb10ForEye(); } 
            else { var target = getTargetEye(); target.sphere += 0.25; updateDisplay("Gain faible -> -0.25 rejeté"); appState.examPhase = "Sb1.0"; appState.checkStep = null; finishSb10ForEye(); }
        }
        return;
    }

    // LOGIQUE Sb1.0
    if (appState.examPhase === "Sb1.0") {

        // --- SÉCURITÉ DE RETOUR (Après CheckPlus/CheckMinus) ---
        if (appState.safety_mode && getTargetEye().sphere >= 0) { // Uniquement Positif ici, Myope géré dans SphereCheckMinus block
            if (lettersRead > appState.safety_mem_letters) {
                // Filtre A: Amélioration confirmée

                if (isPassed) {
                    // Filtre B: Validation Standard (Lapin) -> OK
                    appState.safety_mode = false; 
                    appState.sb10_line_defog = 0; // Reset compteur
                    appState.subj[appState.activeEye].va = currentVA;
                    if (goNextLine()) updateDisplay("Sécurité passée -> Ligne Suivante");
                    else updateDisplay("Max Atteint");
                    return;
                } else {
                    // Filtre B: Echec Validation (Amélioration mais pas Lapin) -> STOP
                    // C'est ici qu'on force la sortie pour éviter la boucle
                    alert("Amélioration confirmée mais plafond atteint. On valide cette sphère.");
                    finishSb10ForEye();
                    return;
                }
            } else {
                // Filtre A Failed: Pas d'amélioration -> REVERT & STOP

                // 1. On annule le débrouillage (On remet +0.25 car le -0.25 était inutile)
                var target = getTargetEye();
                target.sphere += 0.25;

                // --- CORRECTION : ON MET A JOUR L'AFFICHAGE AVANT DE VALIDER ---
                updateDisplay("Sécurité : Retour à la sphère précédente."); 
                // ---------------------------------------------------------------

                // 2. Alert et Fin
                alert("Sécurité : Le débrouillage n'apporte rien. On revient à la sphère précédente (" + target.sphere.toFixed(2) + ") et on valide.");
                finishSb10ForEye();
                return;
            }
        }
        // -------------------------------------------------------

        var sph = getTargetEye().sphere;
        if (currentVA === 1.0) {
            if (sph >= 0) {
                // === CAS SPHÈRE POSITIVE OU NULLE ===
                // 1. Échec
                // 1. Échec
           // 1. Échec
            if (lettersRead < 3 || (lettersRead === 3 && cadence === 'turtle')) {
                // On vérifie si on a déjà tenté DEUX débrouillages sur cette ligne précise
                if (appState.sb10_line_defog >= 2) { 
                    showAmblyopiaSafetyModal();
                    return true; 
                }
                
                // Sinon, on incrémente (0->1, puis 1->2) et on débrouille de -0.25
                appState.sb10_line_defog = (appState.sb10_line_defog || 0) + 1;
                changeSphereAndRetest(-0.25); 
                updateDisplay("Échec -> Tentative de débrouillage (-0.25)");
                say("Ok, et si je fais ceci, pouvez-vous lire ces lettres ?");
                return true; // STOP ICI
            }
               // 2. Succès -> Check Plus
            appState.sb10_line_defog = 0; // RESET : Le patient a réussi, on remet les chances à zéro.
            appState.subj[appState.activeEye].va = currentVA;
            initSphereCheckPlus(); 
            return true;
            } else {
                // === CAS SPHÈRE NÉGATIVE (< 0) ===
                const currentVA = ACUITY_TABLE[appState.vaIndex].va;

                // --- 1. ÉCHECS OU DÉBROUILLAGE EXCESSIF (Lignes 0.5 à 1.0) ---
                if (lettersRead < 3 || (lettersRead === 3 && cadence === 'turtle')) { 
                    
                    // Sécurité plateau automatique (Lignes 0.5 à 1.0)
                    if (appState.sb10_line_defog >= 2) {
                        showAmblyopiaSafetyModal(); 
                        return;
                    }
                    
                    // Débrouillage classique (même au 1.0 si échec franc)
                    appState.sb10_line_defog++;
                    changeSphereAndRetest(-0.25); 
                    updateDisplay("Echec " + currentVA + " (-) -> Débrouille -0.25"); 
                    return; 
                }
                
                // --- 2. RÉUSSITE RAPIDE (LAPIN) ---
                if (lettersRead >= 3 && cadence === 'rabbit') {
                    appState.sb10_line_defog = 0; // Reset sécurité car progrès
                    appState.subj[appState.activeEye].va = currentVA;

                    if (currentVA === 1.0) {
                        if (lettersRead < 5) {
                            // RÉUSSITE PARTIELLE AU 1.0 -> SEUL CAS POUR LE QUART CONCAVE
                            updateDisplay("1.0 partiel (Lapin) -> Test Quart Concave");
                            appState.safety_mode = true;
                            appState.safety_mem_letters = lettersRead;
                            var target = getTargetEye();
                            target.sphere -= 0.25; 
                            initSphereCheckMinus(); 
                        } else {
                            // 5 lettres Lapin au 1.0 -> FIN
                            updateDisplay("1.0 validé (5/5) -> Fin de l'oeil");
                            finishSb10ForEye();
                        }
                    } else {
                        // Avant 1.0 -> Progression normale
                        goNextLine();
                        updateDisplay("Validé -> Ligne suivante");
                    }
                    return;
                }
            }
        }

        // Logique de montée standard avant 1.0
        if (isPassed) {
            appState.subj[appState.activeEye].va = currentVA;
            if (currentVA < 1.0) { if (goNextLine()) updateDisplay("Validé -> Suivant"); else updateDisplay("Max Atteint"); } return;
        } else { 

            // --- CORRECTION CHRONOLOGIQUE : CHECK AVANT DÉBROUILLAGE (POUR SPH >= 0) ---
           if (sph >= 0) {
                // On vérifie d'abord si on a atteint le palier
                if (appState.sb10_line_defog >= 2) {
                    showAmblyopiaSafetyModal();
                    return; // STOP ICI
                }
                // Si non, on marque l'échec pour autoriser le débrouillage qui suit
                appState.sb10_line_defog = (appState.sb10_line_defog || 0) + 1;
            }
            // --- SÉCURITÉ MYOPE (POUR SPH < 0) ---
            else {
                // --- NOUVELLE SÉCURITÉ UNIFIÉE ---
                    if (appState.sb10_line_defog >= 2) {
                        const currentVA = ACUITY_TABLE[appState.vaIndex].va;
                        
                        if (currentVA < 1.0) {
                            // Échec sur 0.5, 0.6 ou 0.8 -> On lance la MODALE (formule +0.50)
                            showAmblyopiaSafetyModal();
                        } else {
                            // Échec sur le 1.0 -> On garde le QUART CONCAVE manuel
                            appState.safety_mode = true;
                            appState.safety_mem_letters = lettersRead;
                            var target = getTargetEye(); 
                            target.sphere -= 0.25; 
                            initSphereCheckMinus();
                        }
                        return;
                    }
                    appState.sb10_line_defog++;
            }
            // ---------------------------------------------------------------------------

            changeSphereAndRetest(-0.25); 
            updateDisplay("Echec " + currentVA + " -> Débrouille -0.25"); 
            return; 
        }
    }

    // --- LOGIQUE FINALE : DÉCISION SUITE À LA RÉPONSE (VERSION EXPERTE) ---
    // --- LOGIQUE FINALE : DÉCISION SUITE À LA RÉPONSE ---
   // --- LOGIQUE FINALE : DÉCISION SUITE À LA RÉPONSE ---
   if (isPassed && cadence === 'rabbit') {
        appState.sb10_line_defog = 0;
        const eyeToSave = appState.activeEye;

        // --- SAUVEGARDE PRIORITAIRE ---
        // On force l'enregistrement dans les deux structures pour être certain
        appState.saved_sb10[eyeToSave] = parseFloat(appState.subj[eyeToSave].sphere);
        
        // Mise à jour de la VA
        appState.subj[eyeToSave].va = currentVA;
        
        if (goNextLine()) {
            updateDisplay("Validé " + currentVA + " -> Sphère " + appState.saved_sb10[eyeToSave].toFixed(2) + " mémorisée");
        } else {
            finishSb10ForEye(); 
        }
        return; 
    }
    else if (isPassed && cadence === 'turtle') {
        // CAS 2 : SUCCÈS HÉSITANT -> Débrouille ET change les lettres
        var target = getTargetEye();
        target.sphere -= 0.25;
        nextLetters(); 
        updateDisplay("Hésitant -> Débrouille -0.25 & Nouvelles lettres");
        
        say([
            "Ok. Essayons comme ceci, relisez ces nouvelles lettres.",
            "D'accord, et comme cela lisez ces nouvelles lettres."
        ]);
        return;
    }
    else {
        // CAS 3 : ÉCHEC (SCORE < 3) -> Débrouille SANS changer les lettres
        var target = getTargetEye();
        target.sphere -= 0.25;
        updateDisplay("Échec " + currentVA + " -> Débrouille -0.25");
        // On ne fait PAS nextLetters() ici !
        return;
    }
  }
    // Fonction utilitaire pour la sécurité Sb1.0
function handleSb10Safety(currentSphere, score) {
    if (currentSphere >= 0) {
        appState.sb10_line_defog++;
        // Si on a débrouillé plus de 0.50 (donc 3 fois 0.25 = 0.75)
        if (appState.sb10_line_defog > 2) {
            // NEW CHECK: Prevent infinite loop
            if (appState.hasRestartedSb10) {
                alert("Sécurité : Seconde tentative échouée. On valide la sphère actuelle.");
                finishSb10ForEye();
                return;
            }

            appState.safety_mode = true;
            // On sauvegarde le vrai score de l'échec
            appState.safety_mem_letters = score; 

            alert("Sécurité : Débrouillage excessif sur sphère positive. Vérification.");
            initSphereCheckPlus();
        }
    }
}
// Fonction de secours pour annuler le verre de test en cas d'échec de gain
function revertMinusLens() {
    var target = getTargetEye();
    if (target.sphere < 0) appState.subj[appState.activeEye].swebDone = true;
    
    // 1. Rétablissement de la sphère initiale
    target.sphere = appState.baseSphereValue; 
    
    appState.isCheckingGain = false;
    appState.examPhase = "Sb1.0"; // On remet une phase neutre par sécurité
    
    // 2. Message de feedback
    updateDisplay("Gain insuffisant : retour à la base.");
    
    // 3. SORTIE DÉFINITIVE VERS L'ASTIGMATISME
    say("Bon, finalement ce n'est pas mieux. On continue.", function() {
        // Cette ligne est cruciale : elle ferme la recherche de sphère
        finishSb10ForEye(); 
    });
}
function changeSphereAndRetest(delta) { var target = getTargetEye(); target.sphere += delta; nextLetters(); }
function nextLetters() { appState.letterIndex++; }
function goNextLine() {
    appState.sb10_line_defog = 0; 
    var currentVA = ACUITY_TABLE[appState.vaIndex].va;

    // --- LOGIQUE SPÉCIFIQUE PHASE Sb0.2 (2/10 vs 2.5/10) ---
    if (appState.examPhase === "Sb0.2") {
        if (currentVA === 0.20) {
            if (appState.defoggedInZone) {
                // CAS A : Débrouillage préalable -> STOP au 2/10
                validateSb02(); 
                return false; // <--- CRITIQUE : Dit à processLogic de s'arrêter
            } else {
                // CAS B : Pas de débrouillage -> Tenter 2.5/10
                appState.vaIndex++; 
                appState.letterIndex = 0;
                return true; 
            }
        }

        if (currentVA === 0.25) {
            if (appState.activeEye === 'OD') appState.seen025_OD = true; 
            else appState.seen025_OG = true;
            validateSb02();
            return false; // <--- CRITIQUE : Arrête le flux
        }
    }

    // LOGIQUE STANDARD
    if (appState.vaIndex < ACUITY_TABLE.length - 1) { 
        appState.vaIndex++; 
        appState.letterIndex = 0; 
        return true; 
    }
    return false;
}
function setVaToIndexClosest(target) { for(var i=0; i<ACUITY_TABLE.length; i++) { if(ACUITY_TABLE[i].va >= target) { appState.vaIndex = i; break; } } appState.letterIndex = 0; }
function askCadence(n) { appState.pendingLetters = n; document.getElementById('standardButtons').classList.add('hidden'); document.getElementById('cadenceButtons').classList.remove('hidden'); updateDisplay("> 3 lettres. Cadence ?"); }
function applyChanges(sphereDelta, message) {
    var currentVA = ACUITY_TABLE[appState.vaIndex].va;
    if (appState.examPhase === "Sb0.2" && sphereDelta < 0 && currentVA >= 0.06 && currentVA <= 0.20) { appState.defoggedInZone = true; }
    var target = getTargetEye(); target.sphere += sphereDelta; updateDisplay(message);
}

function updateDisplay(message) {
    // 1. Mise à jour Panneau Gauche
    let sOD = appState.subj.OD.sphere;
    let sOG = appState.subj.OG.sphere;
  // Récupération des valeurs Fronto (LM)
let fOD = getVal('frontoOD_sph');
let fOG = getVal('frontoOG_sph');

// Affichage avec le signe +
setHTML('frontoOD_sph', (fOD > 0 ? "+" : "") + fOD.toFixed(2));
setHTML('frontoOG_sph', (fOG > 0 ? "+" : "") + fOG.toFixed(2));
// Récupération et formatage des valeurs AR (Autoréfractomètre)
let rOD = getVal('raOD_sph');
let rOG = getVal('raOG_sph');
setHTML('raOD_sph', (rOD > 0 ? "+" : "") + rOD.toFixed(2));
setHTML('raOG_sph', (rOG > 0 ? "+" : "") + rOG.toFixed(2));
   // --- MISE À JOUR DES CARTES DE DONNÉES (PETITS AFFICHEURS) ---
    setHTML('subjOD_sph', (sOD > 0 ? "+" : "") + sOD.toFixed(2)); 
    setHTML('subjOG_sph', (sOG > 0 ? "+" : "") + sOG.toFixed(2));
    setHTML('subjOD_cyl', appState.subj.OD.cyl.toFixed(2)); 
    setHTML('subjOG_cyl', appState.subj.OG.cyl.toFixed(2));
    setHTML('subjOD_axe', appState.subj.OD.axe + "°"); 
    setHTML('subjOG_axe', appState.subj.OG.axe + "°");

    // --- MISE À JOUR DU DASHBOARD CENTRAL (GRANDS AFFICHEURS) ---
    // On utilise les mêmes variables sOD et sOG déjà calculées plus haut
    setHTML('disp_subjOD_sph', (sOD > 0 ? "+" : "") + sOD.toFixed(2));
    setHTML('disp_subjOD_cyl', appState.subj.OD.cyl.toFixed(2));
    setHTML('disp_subjOD_axe', appState.subj.OD.axe + "°");
    setHTML('disp_subjOD_va', formatVA(appState.subj.OD.va));

    setHTML('disp_subjOG_sph', (sOG > 0 ? "+" : "") + sOG.toFixed(2));
    setHTML('disp_subjOG_cyl', appState.subj.OG.cyl.toFixed(2));
    setHTML('disp_subjOG_axe', appState.subj.OG.axe + "°");
    setHTML('disp_subjOG_va', formatVA(appState.subj.OG.va));

    // 2. Mise à jour Panneau Droite (Nouvelle Section Verticale)
    // On récupère les nombres bruts
    let currentSphOD = appState.subj.OD.sphere;
    let currentSphOG = appState.subj.OG.sphere;

    // On injecte le texte formaté avec le signe +
    setHTML('disp_subjOD_sph', (currentSphOD > 0 ? "+" : "") + currentSphOD.toFixed(2));
    setHTML('disp_subjOD_cyl', appState.subj.OD.cyl.toFixed(2));
    setHTML('disp_subjOD_axe', appState.subj.OD.axe + "°");
    setHTML('disp_subjOD_va', appState.subj.OD.va);

    setHTML('disp_subjOG_sph', (currentSphOG > 0 ? "+" : "") + currentSphOG.toFixed(2));
    setHTML('disp_subjOG_cyl', appState.subj.OG.cyl.toFixed(2));
    setHTML('disp_subjOG_axe', appState.subj.OG.axe + "°");
    setHTML('disp_subjOG_va', appState.subj.OG.va);

    // Gestion visuelle de l'œil actif
    var boxOD = document.getElementById('subjDispOD');
    var boxOG = document.getElementById('subjDispOG');
    var btnOD = document.getElementById('btnOD');
    var btnOG = document.getElementById('btnOG');

    // Gestion des classes des colonnes de données
    if(appState.activeEye === 'OD') {
        // Oeil Droit devient Cyan, Oeil Gauche redevient gris/marron
        boxOD.classList.add('highlight'); 
        boxOG.classList.remove('highlight');
    } else {
        // Oeil Gauche devient Cyan, Oeil Droit redevient gris/marron
        boxOG.classList.add('highlight'); 
        boxOD.classList.remove('highlight');
    }

    // Gestion des classes des boutons Yeux (Nouvelle logique Occlusion)
    var isMonocularPhase = (appState.examPhase === "Sb0.2" || appState.examPhase === "Sb0.5");

    if(appState.activeEye === 'OD') {
        btnOD.className = 'eye-btn active';
        btnOG.className = isMonocularPhase ? 'eye-btn occluded-mode' : 'eye-btn';
    } else {
        btnOD.className = isMonocularPhase ? 'eye-btn occluded-mode' : 'eye-btn';
        btnOG.className = 'eye-btn active';
    }

    setHTML('valProfile', appState.profile);
    setHTML('systemMsg', message);
    if (message.indexOf("VALIDÉE") !== -1 || message.indexOf("Validé") !== -1) document.getElementById('systemMsg').classList.add('success-msg'); else document.getElementById('systemMsg').classList.remove('success-msg');

    var currentData = ACUITY_TABLE[appState.vaIndex]; setHTML('valVA', currentData.va);
    var linesArr = currentData.lines; var txt = linesArr[appState.letterIndex % linesArr.length];
    setHTML('letterBox', txt);
    var count = txt.split(' ').length; var btnHTML = "";
    for(var i=0; i<=count; i++) { btnHTML += '<button class="btn-resp" onclick="window.handleResponse('+i+')">'+i+'</button> '; }
    setHTML('btnContainer', btnHTML);

    // Visuals Eye (Gauche) - Masquage des champs de saisie
    // (MODIFIÉ: Suppression de applyVisuals car plus d'éléments à masquer dans le panneau gauche)
}

// --- AXE ---
window.initAxisCheck = function() {
    appState.examPhase = "AxisCheck"; 
    var target = getTargetEye();

    // 1. Mémorisation pour le contrôle qualité
    appState.lettersBeforeAxis = appState.lastResponseCount; 
    appState.axisInitialRA = target.axe;

    // --- RÈGLE CLINIQUE : CHOIX DE LA LIGNE ---
    var currentVA = ACUITY_TABLE[appState.vaIndex].va;
    if (currentVA >= 1.0) {
        setVaToIndexClosest(1.00); 
    }
    
    var raAxis = (appState.activeEye === 'OD') ? getVal('raOD_axe') : getVal('raOG_axe');
    appState.startAxisRA = raAxis; 
    var cyl = Math.abs(target.cyl); 
    appState.cylHigh = (cyl >= 4.50);

    // Initialisation du pas technique
    if (appState.cylHigh) {
        appState.axisStep = 5; 
    } else {
        appState.axisStep = (cyl < 2.50) ? 20 : 10;
    }
    
    // --- CALCUL UNIVERSEL INVERSÉ (TOUR 1) ---
    // Position 1 = Valeur Augmentée (+) | Position 2 = Valeur Diminuée (-)
    if (appState.cylHigh) {
        // MÉTHODE GLISSEMENT : Position 1 (Base) vs Position 2 (Diminuée -5)
        appState.tempPos1 = target.axe; 
        appState.tempPos2 = normalizeAxis(target.axe - 5); 
    } else {
        // MÉTHODE CLASSIQUE : 1 est toujours (+), 2 est toujours (-)
        appState.tempPos1 = normalizeAxis(target.axe + appState.axisStep);
        appState.tempPos2 = normalizeAxis(target.axe - appState.axisStep);
    }
    // -------------------------------------------------------------------------

    appState.axisDirectionHistory = [];
    appState.axisRepeatCount = 0; 
    appState.axisHelpMode = false;

    // --- MISE À JOUR DE L'INTERFACE ---
    document.getElementById('axisZone').classList.remove('hidden');
    document.getElementById('axisControls').classList.remove('hidden');
    document.getElementById('standardButtons').classList.add('hidden');
    
    document.getElementById('jccVisuals').classList.remove('hidden'); 
    document.getElementById('visPos1').classList.remove('active'); 
    document.getElementById('visPos2').classList.remove('active');
    
    document.getElementById('axisDecisions').classList.add('hidden'); 
    document.getElementById('btnReplayAxis').classList.add('hidden'); 
    
    updateDisplay("Axe: Init " + (appState.cylHigh ? "Méthode Glissement" : "Méthode Classique"));

    // --- LOGIQUE D'ANNONCE HARMONISÉE ---
    if (!appState.axisIntroDone) {
        appState.axisIntroDone = true; 
        let phraseIntro = "Je vais maintenant vous montrer deux positions différentes que vous allez comparer et vous me direz avec quelle position vous préférez lire les lettres. Pour cela, il faut que vous lisiez toutes les lettres dans votre tête. De mon côté je ferai pareil, comme cela nous serons plus ou moins synchronisés.";
            
        say(phraseIntro, function() {
            setTimeout(function() { runJccSequence(); }, 1000);
        });
    } else {
        say("Comme tout à l'heure, je vais vous montrer deux positions différentes et vous me direz laquelle vous préférez. N'oubliez pas de lire toutes les lettres dans votre tête.", function() {
            setTimeout(function() { runJccSequence(); }, 1000);
        });
    }
};
  
  window.runJccSequence = function() {
    if (appState.isSpeaking) return; 
    
    window.hideBaseCircle();
    var target = getTargetEye();
    var p1 = document.getElementById('visPos1'); 
    var p2 = document.getElementById('visPos2');
    var axisDecisions = document.getElementById('axisDecisions');
    var replayBtn = document.getElementById('btnReplayAxis');
    var axeDisplay = document.getElementById('disp_subj' + appState.activeEye + '_axe');

    // --- 1. CALCUL DYNAMIQUE UNIVERSEL ET INVERSÉ ---
    if (appState.cylHigh) {
        appState.tempPos1 = target.axe; 
        var lastDir = appState.axisDirectionHistory[appState.axisDirectionHistory.length - 1];
        var stepSign = (lastDir === 'ccw') ? 1 : -1; 
        appState.tempPos2 = normalizeAxis(target.axe + (5 * stepSign));
    } else {
        appState.tempPos1 = normalizeAxis(target.axe + appState.axisStep);
        appState.tempPos2 = normalizeAxis(target.axe - appState.axisStep);
    }

    var pos1_val = appState.tempPos1;
    var pos2_val = appState.tempPos2;

    // INITIALISATION VISUELLE
    document.getElementById('jccVisuals').classList.remove('hidden');
    p1.classList.remove('active');
    p2.classList.remove('active');
    axisDecisions.classList.add('hidden');
    replayBtn.classList.add('hidden');

    // --- SEQUENCE SYNCHRONISÉE (2.5s d'observation) ---

    // ÉTAPE 1 : POSITION 1
    say("Vous préférez la position", function() {
        if (axeDisplay) axeDisplay.innerText = pos1_val + "°";
        p1.classList.add('active'); 

        say("une ?", function() {
            // Pause d'observation Position 1 (2.5s)
            setTimeout(function() {
                p1.classList.remove('active'); 

                // ÉTAPE 2 : POSITION 2 + ENCHAÎNEMENT VOCAL
                say("Ou la position", function() {
                    if (axeDisplay) axeDisplay.innerText = pos2_val + "°";
                    p2.classList.add('active');

                    say("deux, ou est-ce que c'est pareil ?", function() {
                        // Pause d'observation Position 2 (2.5s)
                        setTimeout(function() {
                            p2.classList.remove('active'); 
                            
                            // 1. On cache les bulles 1 et 2 immédiatement après la comparaison
                            document.getElementById('jccVisuals').classList.add('hidden');
                            
                            // 2. Rétablissement de l'axe de référence dans le dashboard
                            if (axeDisplay) axeDisplay.innerText = target.axe + "°";
                            
                            // 3. Affichage des boutons de décision (Mieux 1, Mieux 2, Pareil)
                            axisDecisions.classList.remove('hidden');
                            replayBtn.classList.remove('hidden');
                            
                            // 4. On s'assure que les flèches ne tournent plus en tâche de fond
                            p1.classList.remove('active');
                        }, 2500);
                    });
                }, false);
            }, 2500); 
        }, false);
    }, false); 
};
  window.handleJccChoice = function(choice) {
    if (appState.isSpeaking) return; 

    document.getElementById('axisDecisions').classList.add('hidden');
    document.getElementById('btnReplayAxis').classList.add('hidden');

    var target = getTargetEye();
    var isFinished = false; 
    
    // --- CAS 1 : LE PATIENT DIT "PAREIL" ---
    if (choice === 'same') { 
        isFinished = true;
    } else {
        // Détermination de la direction pour l'historique
        var direction = (choice === 'pos1') ? 'ccw' : 'cw'; // Inversé pour logique cohérente
        var lastDirection = appState.axisDirectionHistory.length > 0 ? 
            appState.axisDirectionHistory[appState.axisDirectionHistory.length - 1] : null;

        // --- SÉCURITÉ : VERROU DES 3 CLICS ---
        if (direction === lastDirection) {
            appState.axisRepeatCount++;
        } else {
            appState.axisRepeatCount = 1;
        }

        if (appState.axisRepeatCount >= 3 && !appState.axisHelpMode) {
            appState.axisRepeatCount = 0;
            appState.axisHelpMode = true; 
            appState.axisDirectionHistory = [];
            appState.axisStep = (appState.cylHigh) ? 5 : (Math.abs(target.cyl) < 2.50 ? 20 : 10);
            target.axe = appState.axisInitialRA;
            updateDisplay("Axe RA rétabli (Sécurité 3 clics)");
            say("C'est curieux. Pour vous aider à mieux répondre, vous allez maintenant lire à voix hautes les lettres pour chacune des positions.", function() {
                setTimeout(function() { runJccSequence(); }, 1000);
            });
            return;
        }

        // --- CAS 2 : LOGIQUE DE CALCUL DE L'AXE ---
        if (appState.cylHigh) {
            // === MÉTHODE CYLINDRE FORT (GLISSEMENT) ===
            if (choice === 'pos2') {
                // Le patient préfère la proposition diminuée (-5)
                target.axe = appState.tempPos2; 
                appState.axisDirectionHistory.push('cw'); // On marque le sens horaire
            } 
            else if (choice === 'pos1') {
                // Si c'est le TOUT PREMIER CHOIX et qu'il préfère RA (Position 1)
                if (appState.axisDirectionHistory.length === 0) {
                    updateDisplay("Inversion : recherche vers les valeurs augmentées (RA + 5°)");
                    // On force le sens anti-horaire pour le prochain tour
                    appState.axisDirectionHistory.push('ccw'); 
                    setTimeout(function() { runJccSequence(); }, 800);
                    return; 
                } else {
                    isFinished = true;
                }
            }
        } else {
            // === MÉTHODE CLASSIQUE (ENCADREMENT) ===
            if (lastDirection && direction !== lastDirection) {
                if (appState.axisStep === 20) appState.axisStep = 10;
                else if (appState.axisStep === 10) appState.axisStep = 5;
            } else if (appState.axisStep === 10 && appState.axisDirectionHistory.length >= 2) {
                appState.axisStep = 5;
            }

            // --- ACTION INVERSÉE POUR CORRESPONDRE À L'AFFICHAGE ---
            // Pos 1 affiche Axe + Step -> On ajoute le pas (+)
            // Pos 2 affiche Axe - Step -> On retire le pas (-)
            var rot = (choice === 'pos1') ? appState.axisStep : -appState.axisStep;
            target.axe = normalizeAxis(target.axe + rot);
            
            if (appState.axisStep === 5) {
                isFinished = true;
            }
            appState.axisDirectionHistory.push(direction);
        }
    }

    // --- SORTIE DU TEST (VALIDATION FINALE) ---
    if (isFinished) {
        document.getElementById('jccVisuals').classList.add('hidden');
        document.getElementById('axisControls').classList.add('hidden');
        appState.examPhase = "AxisVerification";
        appState.axisHelpMode = false;
        appState.axisRepeatCount = 0;

        updateDisplay("Axe fixé : " + target.axe + "° - Vérification finale");
        nextLetters(); 
        say("C'est parfait. Relisez-moi cette ligne s'il vous plaît.");
        document.getElementById('standardButtons').classList.remove('hidden');
    } else {
        updateDisplay("Nouvel Axe : " + target.axe + "°");
        nextLetters();
        setTimeout(function() { runJccSequence(); }, 800);
    }
};
// --- NOUVELLES FONCTIONS DE GESTION DE FLUX (STOP/RESTART) ---
window.restartExam = function() {
    // 1. Hide the modal
    document.getElementById('modalDefogLimit').classList.add('hidden');
    document.getElementById('modalTqsLimit').classList.add('hidden');

    // 2. Reset specific safety flags/counters that might prevent restart
    appState.defoggedInZone = false;
    appState.tqsFogCount = 0;
    // The rest are handled by launchExamSequence, but let's be safe
    appState.sb02_OD_ok = false;
    appState.sb02_OG_ok = false;

    // 3. Relaunch the sequence
    // This function re-reads RA, re-calculates fog, and sets phase to Sb0.2 (for profiles 3)
    window.launchExamSequence();
};

window.prepareCycloStop = function() {
    // Masquer les boutons de choix
    document.getElementById('defogButtons').classList.add('hidden');
    // Afficher le bouton de sauvegarde
    document.getElementById('saveCycloContainer').classList.remove('hidden');
};

window.prepareCycloStopTqs = function() {
    // Masquer les boutons de choix
    document.getElementById('tqsButtons').classList.add('hidden');
    // Afficher le bouton de sauvegarde
    document.getElementById('saveCycloContainerTqs').classList.remove('hidden');
};

window.savePatientData = function() {
    alert("Données sauvegardées pour l'examen sous cycloplégique.");
    location.reload(); 
};
  // --- CORRECTION DU PILOTAGE (A COLLER A LA FIN DU SCRIPT) ---

// 1. Fonction de choix de l'œil (Mise à jour pour le nouveau design)
window.setEye = function(eye) {
    appState.activeEye = eye;
    // On force la mise à jour de l'affichage
    var currentMsg = document.getElementById('systemMsg') ? document.getElementById('systemMsg').innerText : "";
    window.updateDisplay(currentMsg);
};

// 2. Fonction d'affichage principale (Compatible Header Split)
window.updateDisplay = function(message) {
    // A. Mise à jour des colonnes de données (Gauche)
    // Calcul des valeurs avec gestion du signe +
    let sphOD = appState.subj.OD.sphere;
    let sphOG = appState.subj.OG.sphere;

    // Mise à jour de la colonne de gauche (Cartes Subjectif)
    setHTML('disp_subjOD_sph', (sphOD > 0 ? "+" : "") + sphOD.toFixed(2)); 
    setHTML('disp_subjOD_cyl', appState.subj.OD.cyl.toFixed(2));
    setHTML('disp_subjOD_axe', appState.subj.OD.axe + "°"); 
    setHTML('disp_subjOD_va', appState.subj.OD.va);

    setHTML('disp_subjOG_sph', (sphOG > 0 ? "+" : "") + sphOG.toFixed(2)); 
    setHTML('disp_subjOG_cyl', appState.subj.OG.cyl.toFixed(2));
    setHTML('disp_subjOG_axe', appState.subj.OG.axe + "°"); 
    setHTML('disp_subjOG_va', appState.subj.OG.va);

    // --- GESTION VISUELLE BIO-MONOCULAIRE, SWÉB & BALANCE ---
    var boxOD = document.getElementById('subjDispOD'); 
    var boxOG = document.getElementById('subjDispOG');
    
    // Détection si on est dans une phase où les deux yeux sont ouverts
    var isBioMode = (
        appState.examPhase === "Sb1.0" || 
        (appState.examPhase && appState.examPhase.includes("Check")) || 
        (appState.examPhase && appState.examPhase.includes("Swéb")) ||
        appState.examPhase === "QuartConcaveMyope"||
    appState.examPhase === "AxisVerification" // <--- AJOUTEZ CETTE LIGNE
    );

    if(boxOD && boxOG) {
        // Reset des styles
        boxOD.classList.remove('highlight', 'col-bio-inactive');
        boxOG.classList.remove('highlight', 'col-bio-inactive');

        // --- CAS 1 : BALANCE BINOCULAIRE FINALE ---
        if (appState.examPhase === "Balance Binoculaire") {
            boxOD.classList.add('highlight');
            boxOG.classList.add('highlight');
        } 
        // --- CAS 2 : OEIL DROIT ACTIF ---
        else if(appState.activeEye === 'OD') {
            boxOD.classList.add('highlight'); 
            if(isBioMode) boxOG.classList.add('col-bio-inactive'); 
        } 
        // --- CAS 3 : OEIL GAUCHE ACTIF ---
        else {
            boxOG.classList.add('highlight'); 
            if(isBioMode) boxOD.classList.add('col-bio-inactive');
        }
    }

    // B. Mise à jour EN-TÊTE GAUCHE (Pilotage)

    // --- TRADUCTION DES PHASES (CIBLÉE SUR SWÉB) ---
var affichagePhase = "Démarrage";
if (appState.examPhase) {
    switch(appState.examPhase) {
        case "Sb0.2":           affichagePhase = "Recherche de la Sb0.2"; break;
        case "Sb0.5":           affichagePhase = "Recherche de la Sb0.5 (T.Q.S.)"; break;
        case "Sb1.0":           affichagePhase = "Recherche de la Sb1.0"; break;
        
        // --- GROUPEMENT SWÉB ---
        case "Vérification de Swéb":
        case "Vérification de Swéb_AVEC_VERRE":
        case "Vérification de Swéb_CUMUL_FINAL":
            affichagePhase = "Vérification de Swéb"; 
            break;

        // --- SPHÈRE (VÉRIFICATEURS) ---
        case "QuartConcaveMyope": 
            affichagePhase = "Test du Quart Concave"; 
            break;
            
        case "SphereCheckMinus":  
            affichagePhase = (appState.subj[appState.activeEye].sphere < 0) ? 
                             "Test du Quart Concave" : 
                             "Test des verres vérificateurs"; 
            break;
            
        case "SphereCheckPlus":   
            affichagePhase = "Test des verres vérificateurs"; 
            break;

        // --- AXE ---
        case "AxisCheck":         
            affichagePhase = "Mise au point de l'axe"; 
            break;
            
        case "AxisVerification":  
            affichagePhase = "Validation de l'axe"; 
            break;

        // --- FINAL ---
        case "Balance Binoculaire": 
            affichagePhase = "Équilibre et Confort Binoculaire"; 
            break;

        default:                  
            affichagePhase = appState.examPhase.toUpperCase();
    }
}
setHTML('dispPhase', affichagePhase);

    // --- MODE TEXTE ---
    var modeText = "MONOCULAIRE";
    if (isBioMode) modeText = "BIO-MONOCULAIRE";
    if (appState.examPhase === "Balance Binoculaire") modeText = "BINOCULAIRE";
    setHTML('dispMode', modeText);

    // --- GESTION DES BOUTONS PILOTAGE (OD/OG) ---
    var btnPilotOD = document.getElementById('btnPilotOD'); 
    var btnPilotOG = document.getElementById('btnPilotOG');

    if (btnPilotOD && btnPilotOG) {
        btnPilotOD.className = 'btn-pilot'; 
        btnPilotOG.className = 'btn-pilot';

        if (appState.examPhase === "Balance Binoculaire") {
            // Les deux yeux sont "actifs" visuellement
            btnPilotOD.classList.add('active');
            btnPilotOG.classList.add('active');
        } else {
            var isOcclusionMode = (appState.examPhase === "Sb0.2" || appState.examPhase === "Sb0.5" || appState.isMonocularExam);
            if (appState.activeEye === 'OD') {
                btnPilotOD.classList.add('active');
                if (isOcclusionMode) btnPilotOG.classList.add('closed');
                else btnPilotOG.classList.add('open');
            } else {
                btnPilotOG.classList.add('active');
                if (isOcclusionMode) btnPilotOD.classList.add('closed');
                else btnPilotOD.classList.add('open');
            }
        }
    }

    // --- Dans la fonction window.updateDisplay ---

    // --- C. MISE À JOUR EN-TÊTE DROIT (Visuel VA Confirmée) ---
// On récupère les valeurs confirmées par cleanAndSyncVA (ou "--" par défaut)
var confirmedVaOD = appState.subj.OD.va || "--";
var confirmedVaOG = appState.subj.OG.va || "--";

// On injecte les valeurs formatées (ex: 1 devient 1.0) dans les cadrans
setHTML('visBoxOD', formatVA(confirmedVaOD)); 
setHTML('visBoxOG', formatVA(confirmedVaOG));

// Gestion visuelle de l'œil actif sur les boîtes VA
var visOD = document.getElementById('visBoxOD'); 
var visOG = document.getElementById('visBoxOG');

if(visOD && visOG) {
    // Si on est en balance finale, les deux sont allumés
    if (appState.examPhase === "Balance Binoculaire") {
        visOD.classList.add('active-eye');
        visOG.classList.add('active-eye');
    } 
    // Sinon, seul l'œil qui travaille est mis en avant (Cyan)
    else if (appState.activeEye === 'OD') { 
        visOD.classList.add('active-eye'); 
        visOG.classList.remove('active-eye'); 
    } else { 
        visOD.classList.remove('active-eye'); 
        visOG.classList.add('active-eye'); 
    }
}

    // D. Messages
    setHTML('valProfile', appState.profile); 
    setHTML('systemMsg', message);
    var sysMsgEl = document.getElementById('systemMsg');
    if(sysMsgEl) {
        if (message.indexOf("VALIDÉE") !== -1 || message.indexOf("Validé") !== -1) sysMsgEl.classList.add('success-msg'); 
        else sysMsgEl.classList.remove('success-msg');
    }

   // E. Génération des boutons de réponse
    if(window.ACUITY_TABLE && appState.vaIndex < ACUITY_TABLE.length) {
        var currentData = ACUITY_TABLE[appState.vaIndex]; 
        var linesArr = currentData.lines; 
        var txt = linesArr[appState.letterIndex % linesArr.length];
        
        updateVisualAcuityDisplay(currentData.va, txt);

        var count = txt.split(' ').length; 
        var btnHTML = "";
        
        // --- CORRECTION ICI : On vérifie si on doit créer le bouton déjà verrouillé ---
        var lockClass = (appState.isSpeaking) ? " locked" : "";
        var lockAttr = (appState.isSpeaking) ? " style='pointer-events:none;'" : "";

        for(var i=0; i<=count; i++) { 
            btnHTML += '<button class="btn-resp' + lockClass + '"' + lockAttr + ' onclick="window.handleResponse('+i+')">'+i+'</button> '; 
        }
        setHTML('btnContainer', btnHTML);
        // -------------------------------------------------------------------------

        // Gestion de la visibilité des blocs de boutons
        var isSpecialMode = (
            !document.getElementById('cadenceButtons').classList.contains('hidden') || 
            !document.getElementById('checkPlusZone').classList.contains('hidden') || 
            !document.getElementById('axisControls').classList.contains('hidden')
        );

        var stdBtns = document.getElementById('standardButtons');
        if (stdBtns) {
            stdBtns.classList.toggle('hidden', isSpecialMode);
        }
    }
};
// =========================================================
// === NOUVEAU MOTEUR D'AFFICHAGE (CORRIGÉ & INTÉGRÉ) ===
// =========================================================

// Définition des groupes
const VAGroups = [
    { values: [0.06], layout: 'center' },
    { values: [0.08], layout: 'center' },
    { values: [0.10], layout: 'center' },
    { values: [0.12, 0.16], layout: 'space-between' },
    { values: [0.20, 0.25], layout: 'space-between' },
    { values: [0.32, 0.40, 0.50], layout: 'space-between' },
    { values: [0.60, 0.80, 1.00], layout: 'space-between' },
    { values: [1.25, 1.60, 2.00], layout: 'space-between' }
];

// Fonction principale attachée à window pour être accessible partout
// Fonction principale attachée à window pour être accessible partout
window.updateVisualAcuityDisplay = function(selectedValue, activeLetters) {
    const zone = document.getElementById('letterBox');
    
    // Configuration du conteneur (Centrage et Ecartement)
    zone.style.display = 'flex';
    zone.style.flexDirection = 'column';
    zone.style.height = '100%';
    zone.style.width = '100%';
    zone.style.justifyContent = 'center'; 
    zone.style.alignItems = 'center';     
    zone.style.gap = '15px';              
    
    zone.innerHTML = ''; 
    
    const valFloat = parseFloat(selectedValue);
    const group = VAGroups.find(g => g.values.includes(valFloat));
    
    // Sécurité fallback
    if (!group) {
        zone.innerHTML = `<div class="va-line-row line-selected"><span class="optotype-text">${activeLetters}</span></div>`;
        return;
    }

    group.values.forEach(va => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'va-line-row';
        
        const letterSpan = document.createElement('span');
        letterSpan.className = 'optotype-text';
        
        if (va === valFloat) {
            // --- CAS 1 : LIGNE ACTIVE ---
            rowDiv.classList.add('line-selected');
            letterSpan.innerText = activeLetters; 
            letterSpan.style.opacity = "1";
            
            // >>> C'EST ICI LE NOUVEAU CODE (L'ÉTIQUETTE) <<<
            const tag = document.createElement('div');
            tag.className = 'va-tag-value'; // Utilise le style CSS ajouté précédemment
            // --- MODIFICATION : FORCER LE "1.0" ---
            // Si le chiffre est un entier (comme 1), on rajoute ".0"
            if (Number.isInteger(va)) {
                tag.innerText = va + ".0";
            } else {
                tag.innerText = va;
            }
            // --------------------------------------

          // Affiche la valeur (ex: 0.4)
            rowDiv.appendChild(tag);        // Ajoute l'étiquette dans la ligne
            // >>> FIN DU NOUVEAU CODE <<<
            
        } else {
            // --- CAS 2 : LIGNE INACTIVE ---
            letterSpan.innerText = window.getRealLettersFromTable(va); 
            letterSpan.style.opacity = "0.4"; 
        }
        
        // On ajoute d'abord les lettres (qui seront centrées par le CSS)
        rowDiv.appendChild(letterSpan);
        
        // On ajoute la ligne à la zone
        zone.appendChild(rowDiv);
    });
};
// Fonction qui va chercher les lettres exactes dans votre base de données
window.getRealLettersFromTable = function(targetVA) {
    if (typeof ACUITY_TABLE === 'undefined') return "---";
    
    const entry = ACUITY_TABLE.find(line => line.va === targetVA);
    
    if (entry && entry.lines) {
        // Utilise l'index global pour synchroniser les lignes
        const idx = (typeof appState !== 'undefined') ? appState.letterIndex : 0;
        const lineText = entry.lines[idx % entry.lines.length];
        return lineText;
    }
    return "---";
};

// --- FONCTION BOUTON ALÉATOIRE (CORRIGÉE) ---
// --- FONCTION BOUTON ALÉATOIRE (VERSION FINALE AVEC VOIX) ---
window.forceChangeLetters = function() {
    // 1. Sécurité
    if (!appState || !appState.isRunning) return;

    // 2. Logique : changement de lettre et mise à jour affichage
    appState.letterIndex++;
    window.updateDisplay("Lettres changées manuellement");
    
    // 3. Animation du clic
    var btn = document.getElementById('btnRandomLetters');
    if(btn) {
        btn.style.transform = "scale(0.9)";
        setTimeout(function(){ 
            btn.style.transform = ""; // Reset pour le CSS :hover
        }, 150);
    }

    // 4. COMMANDE VOCALE AJOUTÉE ICI
    say("ou plutôt celles-ci.");
};
// --- GESTION AFFICHAGE CERCLE BLEU (BASE) ---
window.showBaseCircle = function() {
    var base = document.getElementById('animBaseCircle');
    if(base) base.classList.add('visible');
};

window.hideBaseCircle = function() {
    var base = document.getElementById('animBaseCircle');
    if(base) base.classList.remove('visible');
    
    // Nettoyage animation PLUS (Gauche)
    var arrow = document.getElementById('animArrowLine');
    var target = document.getElementById('animTargetCircle');
    if(arrow) arrow.classList.remove('active');
    if(target) target.classList.remove('visible');

    // Nettoyage animation MOINS (Droite - NOUVEAU)
    var arrowM = document.getElementById('animArrowLineMinus');
    var targetM = document.getElementById('animTargetCircleMinus');
    if(arrowM) arrowM.classList.remove('active');
    if(targetM) targetM.classList.remove('visible');
};

  // --- FONCTION DE BALANCE BINOCULAIRE FINALE ---
window.restoreBinocularBalance = function() {
    // 1. Rétablissement des deux yeux à leurs Sb1.0 respectives (débrouillage total)
    appState.subj.OD.sphere = appState.saved_sb10.OD;
    appState.subj.OG.sphere = appState.saved_sb10.OG;

    // 2. Passage visuel en mode Binoculaire pour l'interface
    appState.examPhase = "Balance Binoculaire";
    
    // On force l'affichage des deux cartes en Cyan
    appState.activeEye = "OD"; // Temporaire pour forcer le highlight via updateDisplay
    
    updateDisplay("Vision Binoculaire : Rétablissement des puissances nettes.");

    // 3. Annonce vocale
    say("Très bien. Je vous laisse maintenant les deux yeux ouverts. Est-ce que la vision est bien nette et confortable avec les deux yeux ensemble ?");
    
    // 4. Nettoyage de l'interface pour la phase suivante
    document.getElementById('standardButtons').classList.add('hidden');
    document.getElementById('checkPlusZone').classList.add('hidden');
    
    // Note: Ici vous pourrez ajouter l'affichage des boutons pour les tests 
    // d'équilibre bioculaire ou de phorie.
};

  function lancerAnnonceAxe() {
    if (!appState.axisIntroDone) {
        appState.axisIntroDone = true; 
        // Phrase standard pour tout le monde au premier oeil
        say("Je vais maintenant vous montrer deux positions différentes que vous allez comparer. Vous me direz avec laquelle vous préférez lire les lettres. Pour cela, il faut que vous lisiez toutes les lettres dans votre tête. De mon côté je ferai pareil, comme cela nous serons plus ou moins synchronisés.", function() {
            setTimeout(function() { runJccSequence(); }, 1000);
        });
    } else {
        // Phrase de rappel pour le second oeil ou après échec
        say("Comme tout à l'heure, je vais vous montrer deux positions différentes et vous me direz laquelle vous préférez. N'oubliez pas de lire toutes les lettres dans votre tête.", function() {
            setTimeout(function() { runJccSequence(); }, 1000);
        });
    }
}
</script>

  
  
</body>
</html>
